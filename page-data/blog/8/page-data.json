{"componentChunkName":"component---src-templates-blog-index-js","path":"/blog/8/","result":{"data":{"posts":{"edges":[{"node":{"body":"\n<div data-excerpt>\n\nDepending on a project people prefer different ways to adapt BEM.\nThis results\ninto a range of tools for our choice. Today, I am translating Maxim Shkalin's\ndescription of the `BEML` templating pre-processor.\n\nWilling to lighten the development with BEM I propose a tiny extension for the\nHTML syntax (yes, I used to writ all those long CSS classes manually). As the\nname `BEMHTML` is greedily taken by the Yandex guys, let us call it `BEML`.\n\n</div>\n\n## Objective\n\n1. Smooth learning curve<br/>\n   HTML-syntax with no need to transform one language into another.\n1. Portability<br/>\n   The tool has to be easy to use with other languages.\n1. Compatiblity with template engines<br/>\n   Instead of trying to replace them.\n1. Simplicity<br/>\n   Easy to use at any project.\n\nIt might be my habit, but I do not see the need to transform JSON into HTML.\nBEMJSON page description usually looks like spaghetti and is very hard to read\ndue to its syntax. Also I do not think that HTML is wrong. AngularJS has already\nshown that HTML can be much flexible than now. Thus, I decided to follow this\nexample.\n\nMoreover, there is anothe problem with using BEMHTML. You need Node.js running\nfor your backend; or use another JavaScript engine for PHP or Rython with dirty\nhacks like V8JS or PyV8. The otehr way round could be preparation of a rendered\ntemplate, but this sounds even more unnatural.\n\nIt would be nice to have a JavaScript-preprocessor and a relative Grunt task\nwhich can be used for creating the prototypes. Then, with transforming to PHP\nyou can use the same templates in the backend.\n\n## Concept\n\nI had a lot of ideas how to extend HTML with inheritance, includes and loops.\nBut finally I cut them off. It would be too complex to support and then provide\nthe portability. Besides, there is a lot of other template engines; I would\nrather enter into alliance with them than to compete. Finally I got not a\ntemplate engine but a preprocessor (or postprocessor) to the current one.\n\nThe scenario is the following. First, create BEML markup using your template\nengine. Then, past it not to the client but to the post-processor which turns\nBEM syntax into HTML. Funally the HTML goes to the client.\n\nOr, there is a faster way for the braves. You can change your template with\npre-processor which turns BEM attributes into HTML, cache it and use this\nchached copy with your dear template engine. Indeed, the pre-processor does not\ntouch the template engine code.\n\n## Syntax\n\nThis is very simple, you just use 4 more attributes like `block`, `elem`, `mod`\nand `mix`. I suppose it is clear what each of them is responsible for. For the\ncomplex values you can use light JSON dialect with no quotation marks and\noptional curly braces. Finally the tool turns this code:\n\n```html\n<div block=\"b-animals\">\n  <div elem=\"cat\" mod=\"size:big, color:red\"></div>\n</div>\n```\n\ninto the following HTML.\n\n```html\n<div class=\"b-animals\">\n  <div\n    class=\"b-animals__cat\n              b-animals__cat_size_big\n              b-animals__cat_color_red\n              \"\n  ></div>\n</div>\n```\n\nMuch readable.\n\nFull information about the syntax you can learn from the [README on GitHub](https://github.com/zenwalker/node-beml).\n\n## Try now\n\n```bash\nnpm install beml\n```\n\n```js\nvar beml = require(\"beml\");\nvar template = '<div block=\"b-block\" mod=\"size:big\"></div>';\n\nbeml.process(template, function (err, html) {\n  console.log(html);\n});\n```\n\n## Author\n\nThis article is a translaton.\nThe original article by Maxim Shkalin was [posted in his\nblog](http://zenwalker.ru/blog/2014/1/html-preprocessor-for-bem.html). Follow him in the social networks:\n<a class=\"link social-ico__ico social-ico__ico_in-text social-ico__ico_type_twitter\"\nhref=\"https://twitter.com/zenwalker2/\" target=\"_blank\"></a>\n<a class=\"link social-ico__ico social-ico__ico_in-text social-ico__ico_type_github\"\nhref=\"https://github.com/zenwalker/\" target=\"_blank\"></a>\n","excerpt":"Objective Smooth learning curve HTML-syntax with no need to transform one language into another. Portability The tool has to be easy to use with other languages. Compatiblity with…","fields":{"slug":"en/posts/beml-html-preprocessor/","readingTime":{"minutes":2.91}},"frontmatter":{"title":"BEML - an HTML preprocessor for BEM","link":null,"date":"09 April 2014","cover":null}}},{"node":{"body":"\nLast week I met the need to develop a web site which static assets have to be\nhosted on a different server and respond by different URLs than its HTML. This\nis the requirement to all the static files: stylesheets and JavaScript linked to\nthe page as well as imges and fonts mentioned in HTML, CSS and JavaScript\ncode.<excerpt/> However it is obvious that these resources should be local when developing.\nThus, the challenge was to introduce a piece of magic which knows where we aim\nto host the statics and transforms all the relative paths into absolute ones\naccording to it.\n\nThe tools which helped me is called\n[Borschik](http://bem.info/tools/optimizers/borschik/). The name is funny.\nBesides it reffers to a famous Russian/Ukranian soup, it also alludes to a word\n\"сборщик\" [sborschik](.zero)\n, and so might be translated as\n<strike>ass</strike>embler. \"Removing the ass part\" as one of my friends says.\n:-)\n\n<center>\n<iframe src=\"//embed.gettyimages.com/embed/135591409?et=B_T3l-shrE-pr9-ELe_wJw&sig=5haG67PAzCxGourA96ZB7m9LwSket1v9PpvXEXNIkBM=\" width=\"508\" height=\"407\" frameborder=\"0\" scrolling=\"no\"></iframe>\n</center>\n\nIn the [varya/st-deliverer](https://github.com/varya/st-deliverer) public repository\nyou can find a stub project illustrating the solution.\n\n### Project structure\n\nAs you will be able to see later `borschik` is very flexible. So you can use any\nproject structure. In my project I store everything in\n[src folder](b.com/varya/st-deliverer/tree/master/src).\nWhen building I get HTML files in\n[dist/html directory](https://github.com/varya/st-deliverer/tree/gh-pages/dist/html).\nCheck out the code and make sure that static files are linked from a different\nserver by their absolute paths.\n\n```html\n<html>\n  <head>\n    <title>Deliver static assets with Borschik</title>\n    <link rel=\"stylesheet\" href=\"http://varya.github.io/stor.../styles.css\" />\n  </head>\n  <body class=\"page\" background=\"http://varya.github.io/stor.../grungy.jpg\">\n    ...\n  </body>\n</html>\n```\n\n[Open in your browser](http://varya.me/st-deliverer/dist/html/) to enjoy my visual\ndesign and a tom-cat.\n\n### Bring borschik to your project\n\nBorschik is an npm package. So, you can install it globally by runing\n\n```bash\nnpm install -g borschik\n```\n\nI personally prefer local project dependencies, so my project has a\n[package.json](https://github.com/varya/st-deliverer/blob/master/package.json)\nfile:\n\n```js\n{\n  ...\n  \"dependencies\": {\n    \"borschik\": \"0.4.2\"\n  },\n  ...\n}\n```\n\n### Configuration\n\nBefore we start the magic transformation it is needed to instruct `borschik` what\nto transform and how to transform. The [.borschik](https://github.com/varya/st-deliverer/blob/master/.borschik)\nconfiguration file serves for that.\n\n```js\n{\n  \"paths\" : {\n    \"src/img/\": \"http://varya.github.io/stor.../st-deliverer/img/\",\n    \"src/css/\": \"http://varya.github.io/stor.../st-deliverer/css/\",\n    \"src/font/\": \"http://varya.github.io/storage/fonts/\"\n\n  }\n}\n```\n\nNote that you can tune different replacements for different paths. Here I tried\nto illustrate with the fonts.\n\n### Run the command\n\nRun borschik over a file which contains links to local static assets, and you\nwill get the transformation result. For example,\n\n```bash\n./node_modules/borschik/bin/borschik \\\n  --input=src/css/styles.css\n```\n\nFot the building process you will also need an `--output` flag to instruct\n`borschik` where to place the result.\n\nBorschik knows the syntax of web technologies. It will not touch the links\nmentioned in text, for example.\n\n### Build system\n\nNow you can use `borschik` in your project build process. I simply wrote a\n[Makefile](https://github.com/varya/st-deliverer/blob/master/Makefile) with a\nlot of help from [@alexeyten](https://github.com/alexeyten) (tnx!).\nThere is also a grunt plugin [megatolya/grunt-borschik](https://github.com/megatolya/grunt-borschik).<br/>\nIndeed, `borschik` is included into [bem-tools](http://bem.info/tools/bem/bem-tools/)\nand [enb](https://github.com/enb-make/enb) — the two competitive solutions for\nbuilding the projects with BEM structure.\n\n### Result\n\n[Check the cat again](http://varya.me/st-deliverer/dist/html/). Still there?\n\nYou also can learn about other features of `borschik` from the article:\n[http://bem.info/articles/borschik/](http://bem.info/articles/borschik/).\n","excerpt":"Last week I met the need to develop a web site which static assets have to be hosted on a different server and respond by different URLs than its HTML. This is the requirement to all the static files: stylesheets and JavaScript linked to the page as well as imges and fonts mentioned in HTML, CSS and JavaScript code. However it is obvious that these resources should be local when developing. Thus, the challenge was to introduce a piece of magic which knows where we aim to host the statics and transforms all the relative paths into absolute ones according to it. The tools which helped me is…","fields":{"slug":"en/posts/borschik-static-assets/","readingTime":{"minutes":2.565}},"frontmatter":{"title":"Borschik helps with remote static assets","link":null,"date":"10 March 2014","cover":null}}},{"node":{"body":"\nThe recently published [step-by-step tutorial on\ni-bem.js](http://bem.info/tutorials/articles/bem-js-tutorial/) mentioned **YM\nmodular system** as a base for component JavaScript solution behind BEM. Why do\nwe need another modular system? Let us see...\n<excerpt/>\n\nThe author of YM modules, [Dmitry Filatov](https://github.com/dfilatov) recently\ncame up with an [article about YM modules](http://habrahabr.ru/post/213627/) in\nRussian. And below you can find the translation.\n\n<hr/>\n\nSo, one more modular system? Besides CommonJS and AMD? Why should we care?\n\nI will not write why modules and modular systems are needed, there are plenty of\narticles about it. Let us rather proceed to the main question: why do we need\n_another_ modular system?<br/>\nFor sure, there are CommonJS and AMD, but working on large projects with them I faced\nlarge drawbacks. One is that they are synchronous. This is not fatal, but in my\nproject we often had to provie different hacks for it.\n\nLet us say, we have 3 modules: moduleA, moduleB and moduleC. moduleC depends on\nboth moduleA and moduleB. Initially I will describe this in code for all the\nthree solutions:\n\n####CommonJS\n\n_moduleA.js:_\n\n```js\nmodule.exports = \"A\";\n```\n\n_moduleB.js:_\n\n```js\nmodule.exports = \"B\";\n```\n\n_moduleC.js:_\n\n```js\nvar moduleA = require(\"A\");\nmoduleB = require(\"B\");\n\nmodule.exports = moduleA + moduleB + \"C\";\n```\n\n_Linking and usage:_\n\n```js\nvar moduleC = require(\"C\");\nconsole.log(moduleC); // prints \"ABC\"\n```\n\n####AMD\n\n_moduleA.js:_\n\n```js\ndefine(\"A\", function () {\n  return \"A\";\n});\n```\n\n_moduleB.js:_:\n\n```js\ndefine(\"B\", function () {\n  return \"B\";\n});\n```\n\n_moduleC.js:_\n\n```js\ndefine(\"С\", [\"A\", \"B\"], function (moduleA, moduleB) {\n  return moduleA + moduleB + \"C\";\n});\n```\n\n_Linking and usage:_\n\n```js\nrequire([\"С\"], function (moduleC) {\n  console.log(moduleC); // prints \"ABC\"\n});\n```\n\n####YM\n\n_moduleA.js:_\n\n```js\nmodules.define(\"A\", function (provide) {\n  provide(\"A\");\n});\n```\n\n_moduleB.js:_\n\n```js\nmodules.define(\"B\", function (provide) {\n  provide(\"B\");\n});\n```\n\n_moduleC.js:_\n\n```js\nmodules.define(\"C\", [\"A\", \"B\"], function (provide, moduleA, moduleB) {\n  provide(moduleA + moduleB + \"C\");\n});\n```\n\n_Linking and usage:_\n\n```js\nmodules.require([\"С\"], function (moduleC) {\n  console.log(moduleC); // prints \"ABC\"\n});\n```\n\nNothing interesting yet. All three examples are similar, although you may\nnotice the `provide` callback in the YM example. What is it for?\n\nLet us imagine a case that `moduleA` and `moduleB` cannot be resolved immediately\n(synchronously, as it is required by CommonJS and AMD). Sometimes you need to\ndo an asynchronous action first. The simpliest example can be `setTimeout`.\nThere is no way to implement it elegantly with CommonJS and AMD.\nBut with `YM` it can be coded as follows:\n\n_moduleA.js:_\n\n```js\nmodules.define(\"A\", function (provide) {\n  setTimeout(function () {\n    provide(\"A\");\n  });\n});\n```\n\n_moduleB.js:_\n\n```js\nmodules.define(\"B\", function (provide) {\n  setTimeout(function () {\n    provide(\"B\");\n  });\n});\n```\n\n_moduleC.js:_\n\n```js\nmodules.define(\"C\", [\"A\", \"B\"], function (provide, moduleA, moduleB) {\n  provide(moduleA + moduleB + \"C\");\n});\n```\n\nInterestingly `moduleC` does not know anything about asynchronous actions in\nits dependant modules. _Win!_\n\n### Real life example\n\nAs for real file example, I often use the YandexMaps API\n([http://api.yandex.com/maps/](http://api.yandex.com/maps/), API of\n[Yandex.Maps](http://maps.yandex.com/)\npublic service). Yandex.Maps API has a complex loading scheme and this cannot be\ndone synchronously. This means that I cannot simply link it to a page\n`<script type=\"text/javascript\" src=\"url-of-ymaps.js\"></script>` and be sure that\nall the following scripts will get the API code ready. First I need to wait for\nthe event `ymaps.ready` to fire.\n\nThe project I am working for is quite complex; we have many classes inherited\nfrom the basic API. For example, we have a `ComplexLayer` class based on `ymaps.Layer`.\nWith YM modules it is simple to implement. We define a `ymaps` module which loads\nthe API code, waits for the `ymaps.ready` event and then provides itself. All\nthe modules which have the `ymaps` module as a dependency only start to resolve\nafter this. As you can see, other modules know nothing about the asynchronicity of the\nYandex.Map API. _No hacks in code!_\n\n_ymaps.js:_\n\n```js\nmodules.define(\"ymaps\", [\"loader\", \"config\"], function (\n  provide,\n  loader,\n  config\n) {\n  var url =\n    config.hosts.ymaps +\n    \"/2.1.4/?lang=ru-RU\" +\n    \"&load=package.full&coordorder=longlat\";\n\n  loader(url, function () {\n    ymaps.ready(function () {\n      provide(ymaps);\n    });\n  });\n});\n```\n\nThere are 2 other modules in use here: `loader` and `config`. I do not show\ntheir code, but the first one loads scripts and the second one is a hash with\nconstant values.\n\n_ComplexLayer.js:_\n\n```js\nmodules.define('ComplexLayer', ['inherit', 'ymaps'], function(provide, inherit, ymaps) {\n    var ComplexLayer = inherit(ymaps.Layer, ...);\n\n    provide(ComplexLayer);\n});\n```\n\nWe can do the same if jQuery is needed. There is a module to load jQuery:\n\n```js\nmodules.define(\n    'jquery',\n    ['loader',\n    function(provide, loader) {\n\n    loader('//yandex.st/jquery/2.1.0/jquery.min.js', function() {\n        provide(jQuery.noConflict(true));\n    });\n});\n```\n\nThen we make other modules dependent on `jquery` module.\n\nThus, the whole project code is represented with modules. There is no global, no\nneed for agreement on the order of linking the scripts (including third-party ones),\nno dirty hacks for asynchronicity.\n\nAnd to wrap up, let me demonstrate you the YM modular system API (indeed, it has more\nmethods, and these are only the basic ones).\n\n_Defining a module:_\n\n```js\nvoid modules.define(\n    String moduleName,\n    [String[] dependencies],\n    Function(\n        Function(Object objectToProvide) provide,\n        [Object resolvedDependency, ...],\n        [Object previousDeclaration]\n    ) declarationFunction\n)\n```\n\n_Requiring a module:_\n\n```js\nvoid modules.require(\n    String[] dependencies,\n    Function(\n        [Object resolvedDependency, ...]\n    ) callbackFunction\n)\n```\n\nThe project is open source and hosted at GitHub:\n[github.com/ymaps/modules](https://github.com/ymaps/modules).\n","excerpt":"The recently published step-by-step tutorial on i-bem.js mentioned YM modular system as a base for component JavaScript solution behind BEM. Why do we need another modular system? Let us see... The author of YM modules, Dmitry Filatov recently came up with an article about YM modules in Russian. And below you can find the translation.\n\nSo, one more modular system? Besides CommonJS and AMD? Why should we care?\n\nI will not write why modules and modular systems are needed, there are plenty of articles about it. Let us rather proceed to the main question: why do we need another modular system? For…","fields":{"slug":"en/posts/ym-modular-system/","readingTime":{"minutes":4.24}},"frontmatter":{"title":"YM Modular System. Why?","link":null,"date":"25 February 2014","cover":null}}},{"node":{"body":"\nWe usually start developing a web site prototyping the interface and then\nimplementing HTML/CSS and bacis JavaScript. In case\nof using the full BEM stack a tranformation from prototype to a functioning web\nsite goes smoothly. You can clone the project from\n[project-stub](https://github.com/bem/project-stub) and create a static web page\nas it was [described\nearlier](http://bem.info/articles/start-with-project-stub/).\n<excerpt/>\n\nThanks to `BEMHTML` templates, you do not need write all the HTML manually.\nDescribing page sructure in `BEMJSON` rather than writing all the tags manually\nsaves time. But sometimes this is still a lot of work to do, especially for large\npages.\n\nLuckily BEMJSON can include JavaScript pieces to produce some blocks dymamically.\nI created an example of such usage:\n\n```js\n({\n    block: 'page',\n    ...\n    content:[\n        ...\n        {\n            block: 'content',\n            content: (function() {\n                var res = [];\n                for(var i = 0; i < 10; i++) {\n                    res.push({\n                        block: 'button',\n                        content: 'Button ' + (i + 1)\n                    });\n                }\n                return res;\n            })()\n        },\n        ...\n    ]\n})\n```\n\n[full\ncode](https://github.com/varya/dynamic-bemjson/blob/master/desktop.bundles/page1/page1.bemjson.js)\n\nThis JavaScript creates 10 `button` blocks when the page is being built with\n`bem-tools`.\nCheck the [result\npage](http://varya.me/dynamic-bemjson/desktop.bundles/page1/page1.html)\nto see them.\n\nAnother example is a `menu` block. Such interface pieces usually consist of a\nlot of items with minor differences which cases a lot of copy-paste on a page.\nWith JavaScript in BEMJSON this can be easily reduced.\n\n```js\n({\n    block: 'page',\n    ...\n    content:[\n        ...\n        {\n            block: 'menu',\n            content: [\n                {\n                    title: 'Index',\n                    isSelected: false,\n                },\n                {\n                    title: 'Products',\n                    isSelected: true\n                },\n                {\n                    title: 'Contact',\n                    isSelected: false\n                }\n            ].map(function(item){\n                var block = {\n                    block: 'menu',\n                    elem: 'item',\n                    content: item.title,\n                    mods: {\n                        selected: item.isSelected\n                    }\n                };\n                return block;\n            })\n        },\n        ...\n    ]\n})\n```\n\n[full\ncode](https://github.com/varya/dynamic-bemjson/blob/master/desktop.bundles/page2/page2.bemjson.js)\n\nThis gives a [page with a menu of 3 items](http://varya.me/dynamic-bemjson/desktop.bundles/page2/page2.html).\nThe bigger is the array of items, the more you save. Especially when the structure\nof every item changes while developing.\n\nIndeed, this feature is not needed when BEMJSON is a result of 1st layer templates\n(like BEMTREE, priv.js) you can produce as much BEMJSON as is necessary. But with\ninitial development of a static web page, the JavaScript tricks help to avoid\ncopy-paste.\n","excerpt":"We usually start developing a web site prototyping the interface and then implementing HTML/CSS and bacis JavaScript. In case of using the full BEM stack a tranformation from prototype to a functioning web site goes smoothly. You can clone the project from project-stub and create a static web page as it was described earlier. Thanks to  templates, you do not need write all the HTML manually. Describing page sructure in  rather than writing all the tags manually saves time. But sometimes this is still a lot of work to do, especially for large pages.\n\nLuckily BEMJSON can include JavaScript…","fields":{"slug":"en/posts/javascript-in-bemjson/","readingTime":{"minutes":1.76}},"frontmatter":{"title":"JavaScript in BEMJSON","link":null,"date":"21 January 2014","cover":null}}},{"node":{"body":"\nA couple of days ago I was asked about some basic things of using [BEM project\nstub](https://github.com/bem/project-stub/tree/14e24fd17ba66a357a2f6fcdce045065b4eb5d6c)\nfrom someone who is enjoying the full BEM stack (BEM-CSS, i-bem.js and BEMHTML\ntemplates) for their projects. Answering the questions I promised to turn the\ninformation into text as we always skip many important things mistakenly\nconsidering them being primitive.\n<excerpt/>\n\nThe quesion was about `.bem/make.js` configuration file which is needed if you\nuse [bem tools](http://bem.info/tools/bem/bem-tools/) to build your pages. The\n[12th and 13th\nlines](https://github.com/bem/project-stub/blob/14e24fd17ba66a357a2f6fcdce045065b4eb5d6c/.bem/make.js#L12)\ndescribe regular expressions to match `blocks` and `bundles`. And the meaning of\nthese terms turned out to be unclear.\n\nFirst of all, the expressions are to detect folders on the project file system.\nThose which end with `.blocks` store blocks, and those which end with `.bundles`\nstore bundles. The `desktop.blocks` and `desktop.bundles` folders of the project\nstub demonstrate this.\n\nThe purpose of `desktop.blocks` folder should be clear. As BEM is a modular\ndevelopment pattern there has to be a place to store modules, the so-called\n`blocks`. Each block has its own directory to keep all the files needed for this\nparticular interface module. E.g. [one project block\nset](https://github.com/varya/online-shop-dummy/tree/master/desktop.blocks).\n\nThe `desktop.bundles` folder needs some comments. It stores pages, which are the\nresult of blocks applied. Every page has its own folder and inside you can find\ndifferent files needed for a page to function. Examine the [example\nproject](https://github.com/varya/online-shop-dummy/tree/gh-pages/desktop.bundles)\nagain.\n\nThe difference is that block files are coded by a developer, as bundle files are\nbuilt with the tools. Block files are our dear CSS, JavaScript and sometimes templates.\n\n<pre><code>├── desktop.blocks/\n│   ├── goods/\n│   │   ├── <a href=\"https://github.com/varya/online-shop-dummy/blob/master/desktop.blocks/goods/goods.bemhtml\">goods.bemhtml</a>\n│   │   ├── <a href=\"https://github.com/varya/online-shop-dummy/blob/master/desktop.blocks/goods/goods.css\">goods.css</a>\n│   │   ├── <a href=\"https://github.com/varya/online-shop-dummy/blob/master/desktop.blocks/goods/goods.deps.js\">goods.deps.js</a>\n│   │   └── <a href=\"https://github.com/varya/online-shop-dummy/blob/master/desktop.blocks/goods/goods.ie.css\">goods.ie.css</a></code></pre>\n\nReal world analogy of a BEM block (and actually any module of any modular\npattern) can be a buiding brick.\n\n![](http://img-fotki.yandex.ru/get/6730/14441195.30/0_7e0f8_33c1c86c_L.jpg)\n\nBundle files are also what a browser can read: CSS, JavaScript, HTML. _None of\nthem was written by a person, they are built with BEM tools_. Have a look\ninside to be sure that this is robot's code.\n\n<pre><code>├── desktop.bundles/\n│   ├── index/\n│   │   ├── <a href=\"https://github.com/varya/online-shop-dummy/blob/gh-pages/desktop.bundles/index/_index.css\">_index.css</a>\n│   │   ├── <a href=\"https://github.com/varya/online-shop-dummy/blob/gh-pages/desktop.bundles/index/_index.js\">_index.js</a>\n│   │   ├── <a href=\"https://github.com/varya/online-shop-dummy/blob/gh-pages/desktop.bundles/index/index.bemjson.js\">index.bemjson.js</a>\n│   │   └── <a href=\"https://github.com/varya/online-shop-dummy/blob/gh-pages/desktop.bundles/index/index.html\">index.html</a></code></pre>\n\nThink about bem tools as about building crane to pick up the bricks and make a\nhouse with them.\n\n![](http://img-fotki.yandex.ru/get/9058/14441195.30/0_7e0f3_ff76f66a_L.jpg)\n\nBesides _.js, _.css and \\*.html files there is the only one here written by a\ndeveloper. This is\n[index.bemjson.js](https://github.com/varya/online-shop-dummy/blob/gh-pages/desktop.bundles/index/index.bemjson.js),\nthe JSON decription of what are the blocks on a page and what it their nested\nstructure. Sounds logical, as only we human can know what we would like to see\non a page. Everything else is produced by the `bem tools`. Once given\ninformaiton about which blocks to use for a page, they pick them up from\n`desktop.blocks` set of blocks and do their job.\n\nExtending the building-a-house example I can say that `page.bemjson.js` file\nhere is a draft.\n\n![](http://img-fotki.yandex.ru/get/6704/14441195.30/0_7e1ba_9dacd537_L.jpg)\n\nBut why do `bem tools` need the regular expessions?\n\nThis is quite easy. The folders `bem tools` operate with are `levels`. It can\nhelp if you think about a level as about `a set`, a set of entities. There can be\na set of blocks wraped with `desktop.blocks` folder, and a set of result pages\nwraped with `desktop.bundles` folder. In the\n[.bem/levels/](https://github.com/bem/project-stub/tree/14e24fd17ba66a357a2f6fcdce045065b4eb5d6c/.bem/levels)\ncofiguration folder there are some instructions from which bem tools understand\nwhat to do with those different types of levels.\n\nDividing your project entities into blocks and bundles makes it possible to have\ndifferent sets of blocks and different bundles built with those sets. For\nexample, you can store blocks to a desktop and touch versions of your web site\ninto the same repository as well as the pages built with them.\n\n<pre><code>├── desktop.blocks/\n├── desktop.bundles/\n├── touch.blocks/\n└── touch.bundles/</code></pre>\n\nComming back to the real world, not only bricks are the modules but lego blocks\nas well.\n\n![](http://img-fotki.yandex.ru/get/6704/14441195.30/0_7e0f6_f69c7d44_L.jpg)\n\nThey also are to build a house. A pretty different house though.\n\n![](http://img-fotki.yandex.ru/get/9326/14441195.30/0_7e0f4_3d999550_L.jpg)\n\nGoing futher you can detach code common for all the platforms and store it\nseparately.\n\n<pre><code>├── common.blocks/\n├── desktop.blocks/\n├── desktop.bundles/\n├── touch.blocks/\n└── touch.bundles/</code></pre>\n\nWith that structure desktop version of a web site gets source code from both\n`common.blocks` and `desktop.blocks` levels as touch version gets it from\n`common.blocks` and `touch.blocks`.\n\n![](http://img-fotki.yandex.ru/get/6725/14441195.30/0_7e0f5_3e107fd4_L.jpg)\n\nAnd before I wrap up, I cannot stop being delighted by the idea of [BEM project\nstub](https://github.com/bem/project-stub/). I use it a lot myself when starting\nprojects. The [Full stack quick start\ntutorial](http://bem.info/articles/start-with-project-stub/) which you may\nremember demostrates how exactly. So does a friend who asked me about the\nbasics. I never realized before that the project stub makes is possible to start\na BEM project with no knowledge above. :-)\n\nHaving this written I see that describing the BEM basics is pretty easy and not very\ntime-consuming to me being (I hope!) useful for the others. If so, please ask\nwhat you need to know.\n","excerpt":"A couple of days ago I was asked about some basic things of using BEM project stub from someone who is enjoying the full BEM stack (BEM-CSS, i-bem.js and BEMHTML templates) for their projects. Answering the questions I promised to turn the information into text as we always skip many important things mistakenly considering them being primitive. The quesion was about  configuration file which is needed if you use bem tools to build your pages. The 12th and 13th lines describe regular expressions to match  and . And the meaning of these terms turned out to be unclear.\n\nFirst of all, the…","fields":{"slug":"en/posts/blocks-and-bundles/","readingTime":{"minutes":4.095}},"frontmatter":{"title":"Blocks are bricks, and bundles are buildings","link":null,"date":"06 January 2014","cover":null}}},{"node":{"body":"\nA developer using custom fonts in web (don't say this is evil) usually face a\ndilemma.\n\nThe users' main interest is the content of the page not the\nview. It is nice to provide it as fast as possible and then apply a custom font.\nThis blog used to work this way. I provided a script among others in the bundle\nlinked by the end of the page.\n<excerpt/>\n\n```js\n(function (d) {\n  function addFont(url, h, l) {\n    h = d.getElementsByTagName(\"head\")[0];\n    l = d.createElement(\"link\");\n    l.href = url;\n    l.rel = \"stylesheet\";\n    h.appendChild(l);\n  }\n\n  addFont(\n    \"//fonts.googleapis.com/css?\" +\n      \"family=Noto+Serif&subset=latin,cyrillic-ext,cyrillic\"\n  );\n})(document);\n```\n\nThe drawback is obvious. Once a font is loaded and apllied, a user notice\ntwitching as a page is being re-rendering. It is recommended to define a\nsuitable system font in the `font-face`. But there never is a good fit.\nOtherwise there was no need in a custom font.\n\nThe only way to avoid the font rendering jerk is to provide the font in advance.\nWith inlining a base64 of a font into CSS and linking it in `<head>` no\ntwitching is guaranteed as well as increasing page loading time.\n\nFor a while I was deciding between the two variants until my colleague [Roman\nKomarov aka kizu](http://kizu.ru/en/) suggested an elegant solution which is in\nuse right now.\n\nAt the first time a user opens any page of this site, a CSS with the font is\nloaded and stored as a piece of text in the `localStorage`.\n\n```js\n$(function () {\n  if (typeof Storage === \"undefined\") {\n    return;\n  }\n  if (localStorage.getItem(\"varya.me.fonts\") === null) {\n    $.ajax({\n      url: \"../../data/fonts.css\",\n      success: function (response) {\n        localStorage.setItem(\"varya.me.fonts\", response);\n      },\n      dataType: \"text\",\n    });\n  }\n});\n```\n\nBut I do not apply this CSS after loading. So, not jerks. As request is only to\nfill up the storage, it goes after the `domReady`.\n\nBy the time of requesting the next page the custom font is already in the user's\ncomputer. Checking that it is available I apply it to the page. The faster the\nbetter, and as the action costs almost nothing an inline `<head>` script goes\nhere.\n\n```js\n(function (d, s, l, r) {\n  if (typeof s !== \"undefined\" && l.getItem(\"varya.me.fonts\")) {\n    r = [\"<style>\", l.getItem(\"varya.me.fonts\"), \"</style>\"];\n    document.write(r.join(\"\"));\n  }\n})(document, Storage, localStorage);\n```\n\nWith that the blog looks as it should do with 2+ pages loaded. I consider this\nprice for no-twitching custom font as reasonable.\n\nAny ideas of making it even better?\n","excerpt":"A developer using custom fonts in web (don't say this is evil) usually face a dilemma. The users' main interest is the content of the page not the view. It is nice to provide it as fast as possible and then apply a custom font. This blog used to work this way. I provided a script among others in the bundle linked by the end of the page.\n\nThe drawback is obvious. Once a font is loaded and apllied, a user notice twitching as a page is being re-rendering. It is recommended to define a suitable system font in the . But there never is a good fit. Otherwise there was no need in a custom font.\n\nThe…","fields":{"slug":"en/posts/fonts-no-cramp/","readingTime":{"minutes":2.025}},"frontmatter":{"title":"Custom fonts with no cramp","link":null,"date":"26 November 2013","cover":null}}}]}},"pageContext":{"limit":6,"skip":42,"pageCount":10,"currentPage":8}},"staticQueryHashes":[],"slicesMap":{}}