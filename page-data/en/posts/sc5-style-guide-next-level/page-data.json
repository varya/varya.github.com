{"componentChunkName":"component---src-templates-post-js-content-file-path-home-runner-work-varya-github-com-varya-github-com-content-posts-sc-5-style-guide-next-level-index-en-md","path":"/en/posts/sc5-style-guide-next-level/","result":{"data":{"mdx":{"id":"40bf7099-d33c-5a44-8fef-85b59eb400c4","body":"\n<div data-excerpt>\n\nWhen it comes to the large web applications, we often operate with complex components. Such components are not just CSS\nstyles for the pieces of an interface but also their JavaScript interactions and templates. As documentation, the style\nguide should reflect them all. In other words, the components on the style guide's pages should be the same living as in\nproduction.\n\n</div>\n\nAt my recent project, we have been using [SC5 Style Guide](http://styleguide.sc5.io/) in its simplest way - documenting\nthe view of the components. For that, we provided the needed HTML in the KSS code and so has received the rendered\ncomponent library.\n\nHowever, in the production code, these components appeared at the pages as a result of some templating transformations.\nAlso, the project is massive and fast-developed, and the changes to the templates happened all the time. As a result,\nthe style guide was always out of date.\n\nMoreover, much functionality could not be illustrated with plain HTML.\nTo be rendered correctly and interact with a user, it also needs its JavaScript code.\n\nAt this project, I have solved the problem using advanced configuration of SC5 Style Guide. Below you can find the\ntricks and explanation.\n\n## Living JavaScript components\n\nUsually, a piece of an interface (often called 'a component') is a combination of HTML, CSS, and JavaScript. With the\nbasic features if SC5 Style Guide you can easily document HTML and CSS. However, applying JavaScript to the components\nrequires an additional configuration.\n\nIn SC5 Styleguide, you can provide additional tags into the `<head>` section of the generated style guide's page. They\ncan be `<script>` tags linking the JavaScript you need.\n\nAssuming this, you can bundle the necessary JavaScript into one file, and link it to the style guide's pages, like this:\n\n```\ngulp.task(\"styleguide:generate\", function() {\n\n  return gulp.src([\"path/to/css/**/*.sass\"])\n    .pipe(styleguide.generate({\n      title: \"My Styleguide\",\n      ...\n      extraHead: [\n        '<script src=\"/js/all-components.js\"></script>',\n        ...\n      ]\n    ...\n```\n\nAnother option for you to use in the configuration is `disableEncapsulation: true`. By default, the tool wraps every\ncomponent into a Shadow DOM container. It makes the components encapsulated and protects from unwanted impact of global CSS.\nAlso, the Shadow DOM wrapper prevents global JavaScript to access the components. Disabling this function, you can give\nthe JavaScript all the access, the same way as it works on a usual page.\n\nIn most cases, JavaScript for the components requires initialization. On the style guide's pages a `styleguide:onRendered`\nevent emits when a component is rendered. You can listen for this event and initialize the components in the event's\nhandler function.\n\nFor example, if using jQuery:\n\n```\n$(window).on('styleguide:onRendered', function(e) {\n  // e.originalEvent.detail.elements[0] - component's container\n  initComponent(e.originalEvent.detail.elements[0])\n});\n```\n\n## Additional processors\n\nThe SC5 Style Guide parses the KSS documentation in your CSS (SASS, LESS) code, collects information about all the\ncomponents and produces a JSON file with it. The documentation pages you can see are the Angular pages built\non the information in this JSON.\n\nGenerating the style guide, you can inject additional processors into transforming data for this JSON file. The\ncustom processing functions can re-organize and modify this data. You can use this trick to provide a more clever\ngenerator, run templates and parametrized JavaScript components.\n\nExamine the generated `styleguide.json` file to see how the data is organized by default. You are going to find out that\nevery component is represented by an object similar to the following:\n\n```\n{\n  header: \"Sub navigation tabs\",\n  description: \"<p class=\"sg\">Navigation item</p> \",\n  modifiers: [ ],\n  deprecated: false,\n  experimental: false,\n  reference: \"4.15.1\",\n  markup: \"<ul class=\"sub-navigation-tabs\">...<ul>\",\n  css: \".sub-navigation-tabs { /* some css */ }\",\n  syntax: \"less\",\n  file: \"tabs.less\",\n  parentReference: \"4.15\",\n  wrapper: \"<sg-wrapper-content/>\",\n  renderMarkup: \"<ul class=\"sub-navigation-tabs\">...<ul>\",\n  variables: [\n    \"colorMain\",\n    \"bgColorSecond\",\n    \"textColor\",\n    \"textColorHover\"\n  ],\n  fileHash: \"d00311f793d66a9e9dee9939dedd9fd9\"\n}\n```\n\nTo modify this data, provide additional processing function as `styleguideProcessors` option. For example,\n\n```\ngulp.task(\"styleguide:generate\", function() {\n\n  return gulp.src([\"path/to/css/**/*.sass\"])\n    .pipe(styleguide.generate({\n      title: \"My Styleguide\",\n      ...\n      styleguideProcessors: {\n        30: processTemplates\n      }\n    ...\n```\n\nAs a value of this option, you can list the processing functions. The given indexes matter for the order in which these\nfunctions are applied to the data.\n\nCheck out [the documentation for options](https://github.com/SC5/sc5-styleguide#build-options).\n\nIn my projects, I used additional processors to operate custom KSS parameters and modify data.\n\n## Custom KSS data\n\nIn the section descriptions, you can provide additional KSS parameters with the names prefixed with `sg-`. For example,\nyou can provide a path to a template which produces the markup for the component:\n\n```\n// Button\n//\n// markup:\n// { title: \"Move on\", type=\"submit\" }\n//\n// sg-template:\n// src/components/button/button.ejs\n//\n// Styleguide 1.2.3\n```\n\nIn here the markup works as an input value for the given template. You can teach Style Guide to apply the template to\nthe declared object and put the result as a markup to render. To do it you need a custom processing function mentioned\nabove.\n\n```\nvar processTemplates = (styleguide) => {\n\n  styleguide.sections.forEach((section) => {\n\n    if (section['sg-template']) {\n      var templatePath = section['sg-template'].trim()\n      templatePath = path.join(process.cwd(), templatePath)\n\n      var templateStr = fs.readFileSync(templatePath, 'utf8')\n      var inputData = eval('(' + section.markup + ')')\n\n      section.renderMarkup = ejs.render(templateStr, insertData)\n    }\n\n  }\n\n}\n```\n\n## Templates on fly\n\nIn the single-page applications, templates work on the client side. In this case, it is better to process them\nin the style guide too. In other words, you should include the templates into the JavaScript bundle and initialize\nthe components on containers.\n\nCombining this approach to the custom processors, you can store the code example for every compoentn in the `markup`\nKSS field.\n\nFor example,\n\n```\n// Tabs\n//\n// markup:\n// var Tabs = require('src/components/tab.js')\n// Tabs.init($container, { items: [...] })\n//\n// sg-js-component:\n// <div class=\"sg-tabs-container\"></div>\n//\n// Styleguide 1.2.3\n```\n\nWith a custom processor, you can put the container's code as a markup to render:\n\n```\nvar processorForJsComponents = function(styleguide) {\n\n  styleguide.sections.forEach((section) => {\n    if (section['sg-js-component']) {\n      section.renderMarkup = section.wrapper.replace(\n        '<sg-wrapper-content/>', section['sg-js-component']\n      );\n    }\n  }\n\n}\n```\n\n## Adjustable initialization for JavaScript\n\nUsually, different components need to be initialized in differently. Also, they may require some fake data. You can\nrun various Javascript functions on separate component containers to get this result.\n\n```\nvar TabsInit = require('src/components/tabs/tabs.init.js')\n\nvar knownComponents = {\n  '.sg-tabs-container': TabsInit\n}\n\n$(window).on('styleguide:onRendered', function(e) {\n\n  knownComponents.forEach((componentInit, componentSelector) => {\n    var containingComponents = $(e.originalEvent.detail.elements[0]).find(componentSelector)\n    if (containingComponents.length > 0) {\n      componentInit(containingComponents)\n    }\n  })\n\n})\n```\n\nThis code runs a corresponding function for every selector in the `knownComponents` object. The matching DOM element(s)\npassed into the initializing function as a parameter.\n\n```\n// src/components/tabs/tabs.sg-init.js\n\nvar Tabs = require('./tabs.js')\n\nvar fakeData = [\n  { title: 'Tab1', url: '/index.html' },\n  { title: 'Tab2', url: '/contacts' }\n]\n\nmodule.exports = function($container) {\n  // Real calling for initing function depends on\n  // you component system interface\n  Tabs.init($container, { items: fakeData })\n}\n\n```\n\nIn this system, you can have several containers with the same CSS class but parametrized with any other information, e.g.\ndata attributes:\n\n```\n// Tabs, another version\n//\n// markup:\n// var Tabs = require('src/components/tab.js')\n// Tabs.init($container, { another: true, items: [...] })\n//\n// sg-js-component:\n// <div class=\"sg-tabs-container\" data-type=\"another\"></div>\n//\n// Styleguide 1.2.4\n```\n\n```\n...\nmodule.exports = function($container) {\n  var type = $container.data('type')\n\n  if (type == 'another') {\n    Tabs.init($container, { another: true,  items: fakeData })\n  } else {\n    Tabs.init($container, { items: fakeData })\n  }\n}\n```\n\n## File structure\n\nYou may have noticed that I suggest storing everything related to the component under the same folder. This is also\nrelevant to the style-guide-related files.\n\nFor a user, a component is a consistent entity. They get it as a whole thing, no matter how many technologies\nare behind. For a developer, it is not that straightforward. We use CSS for styling, JavaScript for interactions and HTML\nfor the view. The corresponding code is usually placed in a separate file for each technology. I find it quite\ndistracting.\n\nHowever, the 'component folder' approach smoothes this situation. Storing everything (including the documentation) in\nthe same place improves developer's experience very much.\n\n```\nsrc/\n  components/\n    login/\n      login.ejs\n      login.js\n      login.sg-init.js\n    tabs/\n      tabs.ejs\n      tabs.js\n      tabs.sass\n      tabs.sg-init.js\n```\n\n## Enjoy\n\nAfter ajusting the SC5 Style Guide, as shown above, you will get the double living documentation. Remember about the\nwatching mode to re-generate the style guide on the file changes. It works as a nice development playground.\n\nAlso, last but not least, I would like to thank the community which made these things possible. I used the SC5 Style Guide\nfeatures by other developers and so feel very grateful. You may see their names [at the releases'\npage](https://github.com/SC5/sc5-styleguide/releases). If you want yours to appear here, please\n[contribute](https://github.com/SC5/sc5-styleguide).\n","fields":{"slug":"en/posts/sc5-style-guide-next-level/","disqusIdentifier":"posts-sc5-style-guide-next-level-index-en","readingTime":{"minutes":7.095}},"frontmatter":{"title":"Living SC5 Styleguide, the next level","subTitle":null,"date":"23 May 2016","v2":true,"old":null,"tumblr":null,"tags":null,"meta":{"desc":"Living documentaion for CSS, JavaScript and templates of your components with SC5 Style Guide. In this post I share my experience from the recent large project.\n"},"canonical":null,"cover":{"childImageSharp":{"gatsbyImageData":{"layout":"fixed","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/5677907f093a3a587d0c6a6fc18d6a91/b5380/thumb.png","srcSet":"/static/5677907f093a3a587d0c6a6fc18d6a91/b5380/thumb.png 1200w","sizes":"1200px"},"sources":[{"srcSet":"/static/5677907f093a3a587d0c6a6fc18d6a91/81547/thumb.webp 1200w","type":"image/webp","sizes":"1200px"}]},"width":1200,"height":630}}}}},"site":{"siteMetadata":{"siteUrl":"https://varya.me"}}},"pageContext":{"slug":"en/posts/sc5-style-guide-next-level/","prev":{"id":"547e65d9-2b51-508c-a0dd-b8885f615a25","fields":{"slug":"en/posts/react-angular-project/","disqusIdentifier":"posts-react-angular-project-index-en","level":1,"fileRelativePath":"react-angular-project/index_en.md","lang":"en","readingTime":{"minutes":3.65}},"frontmatter":{"title":"Simple React Angular project","subTitle":null,"link":null,"v2":true,"old":null,"date":"2016-05-19T00:00:00.000Z","layout":"post","tags":null},"internal":{"contentFilePath":"/home/runner/work/varya.github.com/varya.github.com/content/posts/react-angular-project/index_en.md"}},"next":{"id":"c59501b5-a54b-533a-9a1b-9e179d01db6e","fields":{"slug":"en/posts/week-44-2016/","disqusIdentifier":"posts-week-44-2016-index-en","level":1,"fileRelativePath":"week-44-2016/index_en.md","lang":"en","readingTime":{"minutes":2.565}},"frontmatter":{"title":"Week 44, 2016","subTitle":null,"link":null,"v2":true,"old":null,"date":"2016-11-08T00:00:00.000Z","layout":"post","tags":null},"internal":{"contentFilePath":"/home/runner/work/varya.github.com/varya.github.com/content/posts/week-44-2016/index_en.md"}},"fileSourceUrl":"https://github.com/varya/varya.github.com/edit/develop/content/posts/sc5-style-guide-next-level/index_en.md","frontmatter":{"title":"Living SC5 Styleguide, the next level","date":"2016-05-23T00:00:00.000Z","v2":true,"cover":"thumb.png","layout":"post","meta":{"desc":"Living documentaion for CSS, JavaScript and templates of your components with SC5 Style Guide. In this post I share my experience from the recent large project.\n"}}}},"staticQueryHashes":[],"slicesMap":{}}