{"componentChunkName":"component---src-templates-post-js-content-file-path-home-runner-work-varya-github-com-varya-github-com-content-posts-dealing-atomically-with-icon-fonts-index-en-md","path":"/en/posts/dealing-atomically-with-icon-fonts/","result":{"data":{"mdx":{"id":"377702af-2ec6-57f3-b89f-2cafe1b10550","body":"\n<div data-excerpt>\n\nMy recent huge project was developing a library of CSS and JavaScript components for sharing this code across a lot of\nweb services and mobile apps. In most cases such work brings up question about how to avoid blocking the processes.\n\nThe library has its own flow, and obviously the new things can only appear in new versions. Although I made my best to\nprovide fast releases, and so the library has them 2-3 times a week, it is still understandable that the library\ncustomers sometimes cannot wait even an hour.\n\nI belive that one of the must-haves of UI library is the freedom which it should give to its customers. You can easily\nprovide this if practice atomic approach everythere. For example, for the icon fonts.\n\n</div>\n\n### Solid piece\n\nSoon or not SVG will conquer the world. But now we still have icon fonts in some projects. The same story was with that\nlibrary.\n\nHowever the icon font perfectly suited for the displaying icons onto the web pages, it was integration and flow which\ncreated the problem. All the icons fit into one font file (well, in 4 different formats):\n\n```\nsrc/\n  fonts/\n    iconfont.eot\n    iconfont.svg\n    iconfont.ttf\n    iconfont.woff\n```\n\nAlso the library provided CSS to make the icon-symbol matching:\n\n```scss\n.icon {\n  font-family: $global-font-icon;\n  &:before {\n    /* Some common icon stuff */\n  }\n  &--support {\n    &:before {\n      content: \"a\";\n    }\n  }\n  &--chat {\n    &:before {\n      content: \"b\";\n    }\n  }\n  ...\n}\n```\n\nCustomers get the library as a bower or npm package. When they need a new icon to be in the set, they might request this\nand wait for the package to update. As usual, the fastest way to get something happened is to do this yourself. So, it\npossible to contribute and even release yourself. But still any further change would need you to go through the\ndevelopment process.\n\n### Atomic and buildable\n\nOften you need to divide into smaller pieces in order to make things more mantainable. The same goes with icons. In the\nlibrary we changed it so that the source is now a set of SVG files:\n\n```\nsrc/\n  icons/\n    1000-support.svg\n    1010-chat.svg\n    1020-users.svg\n```\n\nThe file names are important, these words are used to generate the CSS classes, which are the API for the customer.\nNumbers are for the right order. If building the icon system from very beginning, they are not needed. But in the\nlibrary case I wanted backward compatibility.\n\nThen, these icons are built into the same icon fonts with `gulp-iconfont` plugin:\n\n```js\nvar gulp = require(\"gulp\");\nvar iconfont = require(\"gulp-iconfont\");\nvar consolidate = require(\"gulp-consolidate\");\n\nvar sourcePath = \"src/\";\n\ngulp.task(\"build:icons\", function () {\n  return gulp\n    .src([sourcePath + \"/icons/*.svg\"])\n    .pipe(\n      iconfont({\n        fontName: \"myicons\",\n        formats: [\"ttf\", \"eot\", \"woff\", \"svg\"],\n        centerHorizontally: true,\n        fixedWidth: true,\n      })\n    )\n    .on(\"glyphs\", (glyphs) => {\n      glyphs.forEach((icon) => {\n        icon.name = icon.name.replace(/^\\d+\\-/g, \"\");\n      });\n\n      gulp\n        .src(sourcePath + \"/icons/util/*.scss\") // Template\n        .pipe(\n          consolidate(\"lodash\", {\n            glyphs: glyphs,\n            fontName: \"myiconfont\",\n            fontPath: \"../fonts/\",\n          })\n        )\n        .pipe(gulp.dest(sourcePath + \"/scss/\"));\n    })\n    .pipe(gulp.dest(sourcePath + \"/fonts/\"));\n});\n```\n\nBesides the icon files this task needs the templates to produce the CSS (or SCSS, as in this case) which makes the\nsymbol-class matching. I found it logical to store it together with the icon files:\n\n```\nsrc/\n  icons/\n    utils/\n      iconfont__icons.scss\n      iconfont__variables.scss\n```\n\nIt's possible to manage with one template only, but for even more flexibility I have two. The main one makes the\nclasses:\n\n```css\n@font-face {\n  font-family: $global-font-icon;\n  src:url(\"<%= fontPath %><%= fontName %>..eot\");\n  src:url(\"<%= fontPath %><%= fontName %>.?#iefix\") format(\"embedded-opentype\"),\n    url(\"<%= fontPath %><%= fontName %>.woff\") format(\"woff\"),\n    url(\"<%= fontPath %><%= fontName %>.ttf\") format(\"truetype\"),\n    url(\"<%= fontPath %><%= fontName %>.#<%= fontName %>\") format(\"svg\");\n  font-weight: normal;\n  font-style: normal;\n}\n\n.icon {\n  font-family: $global-font-icon;\n\n  &:before {\n    /* Some common icon stuff */\n  }\n<% _.each(glyphs, function(glyph) { %>\n  &.--<%= glyph.name %> {\n    &:before {\n      content: $icon--<%= glyph.name %>;\n    }\n  }<% }); %>\n\n}\n```\n\nAnd another one makes the varibles:\n\n```css\n<% _.each(glyphs, function(glyph) { %>\n$icon-<%= glyph.name %>: \"\\<%= glyph.unicode[0].charCodeAt(0).toString(16).toUpperCase() %>\" !default;\n<% }); %>\n```\n\nRunning the task produces the fonts and 2 generic SCSS files:\n\n```\nsrc/\n  font/\n    iconfont.eot\n    iconfont.svg\n    iconfont.ttf\n    iconfont.woff\n  scss/\n    icons.scss // Not generic\n    iconfont__icons.scss\n    iconfont__variables.scss\n```\n\nIn the `icons.scss`, which is normal SCSS file, the result is requested:\n\n```css\n// Icons\n//\n// Lists all the icons that are used in the services.\n//\n// Styleguide 5\n\n@import \"iconfont__variables.scss\";\n@import \"iconfont__icons.scss\";\n```\n\n### Extend on fly\n\nThe variables may be redefined on the customer's side. This makes is a fast way to change the icon, if the replacement\nalready sit in the font bundle.\n\nIf not, it is almost zero amout of work to implement this build-from-atoms process on the customer side.\n\nThe customer has all the library code, let's say in `bower_components`, and can have its own folder of icons:\n\n```\nbower_components/\n  ui-library/\n    dist/\n      icons/\n      scss/\nsrc/\n  icons/\n    2000-rabbit.svg\n    2010-gift.svg\n```\n\nWhen building the font they need to use both their set of icons and the library icons:\n\n```js\nvar sourcePath = \"src/\";\n\ngulp.task(\"build:icons\", function () {\n  return gulp\n    .src([\n      sourcePath + \"/icons/*.svg\",\n      \"bower_components/ui-library/dist/icons/*.svg\",\n    ])\n    .pipe(\n      iconfont({\n        /* The same as above */\n      })\n    )\n    .on(\"glyphs\", (glyphs) => {\n      gulp\n        .src(\"bower_components/ui-library/dist/icons/util/*.scss\")\n        .pipe(\n          consolidate(\"lodash\", {\n            /* The same as above */\n          })\n        )\n        .pipe(gulp.dest(sourcePath + \"/scss/\"));\n    })\n    .pipe(gulp.dest(sourcePath + \"/fonts/\"));\n});\n```\n\nIt is not even needed to implement template for the output SCSS, it comes in the library dist.\n\nWith such a flow a UI library customer stays completely independent from the library release cycle and may bring a new\nicon into her product as soon as the atomic SVG file is copied into the needed folder. As a background process it is\nneeded to contribute the same icon into the library, but not necessarily the same moment. And even the contributing\nprocess is changed to be better because it came to adding an SVG file.\n\nAs other atomical things, such font flow makes git history more useful. Now it is easier to see\nif the provided change affected many or just one icon. Also, SVG images are rendered nicely in pull requests.\n\nEven simultaneous changes of the icons in both library and customer websites are possible and should not cause any\nconflict.\n\nAnd the last but not least nice thing: all the icons are now in the library as SVG files. Hopefully later we come up\nwith using next century technologies and not the icons fonts. When this sweet moment comes, half of the work will have\nbeen done :-)\n","fields":{"slug":"en/posts/dealing-atomically-with-icon-fonts/","disqusIdentifier":"posts-dealing-atomically-with-icon-fonts-index-en","readingTime":{"minutes":5.385}},"frontmatter":{"title":"Dealing atomically with icon fonts","subTitle":null,"date":"10 November 2015","v2":true,"old":null,"tumblr":null,"tags":null,"meta":{"desc":"Fixing the \"using UI library\" workflow with building icon fonts from atomic SVG icons. The library has its own flow, and obviously the new things can only appear in new versions. However the library customers sometimes cannot wait even an hour. With the atomic builds you can easily provide library customer with the freedom to modify everything. Even icon fonts.\n"},"canonical":null,"cover":{"childImageSharp":{"gatsbyImageData":{"layout":"fixed","backgroundColor":"#585858","images":{"fallback":{"src":"/static/5ff1b90224ede4179ee3616d1d5da5ee/f0233/thumb.png","srcSet":"/static/5ff1b90224ede4179ee3616d1d5da5ee/f0233/thumb.png 600w","sizes":"600px"},"sources":[{"srcSet":"/static/5ff1b90224ede4179ee3616d1d5da5ee/b7dec/thumb.webp 600w","type":"image/webp","sizes":"600px"}]},"width":600,"height":350}}}}},"site":{"siteMetadata":{"siteUrl":"https://varya.me"}}},"pageContext":{"slug":"en/posts/dealing-atomically-with-icon-fonts/","prev":{"id":"202b6ceb-9c1a-568e-bec5-5264e53f0bdf","fields":{"slug":"en/posts/pseudo-tag-cloud-css/","disqusIdentifier":"posts-pseudo-tag-cloud-css-index-en","level":1,"fileRelativePath":"pseudo-tag-cloud-css/index_en.md","lang":"en","readingTime":{"minutes":1.63}},"frontmatter":{"title":"Tag cloud of random sizes in pure CSS","subTitle":null,"link":null,"v2":true,"old":null,"date":"2015-11-02T00:00:00.000Z","layout":"post","tags":null},"internal":{"contentFilePath":"/home/runner/work/varya.github.com/varya.github.com/content/posts/pseudo-tag-cloud-css/index_en.md"}},"next":{"id":"9a86729c-8065-5cee-b67a-d49edc342011","fields":{"slug":"en/posts/image-diffs-with-git/","disqusIdentifier":"posts-image-diffs-with-git-index-en","level":1,"fileRelativePath":"image-diffs-with-git/index_en.md","lang":"en","readingTime":{"minutes":2.125}},"frontmatter":{"title":"Visual diffs for the images in a git repo","subTitle":null,"link":null,"v2":true,"old":null,"date":"2016-03-18T00:00:00.000Z","layout":"post","tags":null},"internal":{"contentFilePath":"/home/runner/work/varya.github.com/varya.github.com/content/posts/image-diffs-with-git/index_en.md"}},"fileSourceUrl":"https://github.com/varya/varya.github.com/edit/develop/content/posts/dealing-atomically-with-icon-fonts/index_en.md","frontmatter":{"title":"Dealing atomically with icon fonts","date":"2015-11-10T00:00:00.000Z","v2":true,"cover":"thumb.png","layout":"post","meta":{"desc":"Fixing the \"using UI library\" workflow with building icon fonts from atomic SVG icons. The library has its own flow, and obviously the new things can only appear in new versions. However the library customers sometimes cannot wait even an hour. With the atomic builds you can easily provide library customer with the freedom to modify everything. Even icon fonts.\n"}}}},"staticQueryHashes":[],"slicesMap":{}}