{"componentChunkName":"component---src-templates-post-js","path":"/ru/posts/efficient_xslt_techniques/","result":{"data":{"mdx":{"id":"ad2cad5c-7fa6-5ed3-8790-11e45a522f6d","body":"\nПеревод документа [XSLT - Efficient Programming\nTechniques](http://www.xml.org/sites/www.xml.org/files/xslt_efficient_programming_techniques.pdf),\nкоторый мне очень помог.\n\nС ростом популярности XML как средства взаимодействия с различными системами,\nвсе больше и больше организаций приходят к XML, чтобы решить свои вопросы\nфункциональной совместимости.<excerpt/> Вместе с попытками архитекторов достигнуть ясного\nразделения между отображением и бизнес-логикой, XSLT становится важнее. XSL, по\nсути, - это XML-документ (дерево, согласно спецификации DTD), который\nприменяется к древовидным структурам данных (XML-документ), чтобы выработать\nрезультирующее дерево.\n\nЭта статья представляет список лучших приемов, используемых для написания\nXSLT-преобразований. Эта статья может быть использована как направление к\nлучшему пути достижения нужных результатов в XSL. Она предназначается для\nразработчиков, которые знакомы с основами XSL, но нуждаются в указателе на\nдейственный путь программирования на XSL. Информация в этой статье основана на\nмоём собственном опыте в XML и XSL. Список лучших приемов составлен по различным\nисточникам, чтобы сделать всеобъемлющий документ, который будет расти, если\nнайдётся больше хороших приемов. Если у вас есть несколько очень хороших\nприёмов, которым вы следуете и которых нет в этом списке, скиньте мне на email\n_[pboundre@gr.com](mailto:pboundre@gr.com)_.\n\n## Подключение внешних файлов - правильный путь\n\nЕсть три способа включения внешних файлов в ваш xsl:\n\nЕсли у вас есть дополнительные HTML-файлы, которые вы хотите включить в ваш\nрезультат без изменений, возможно самый простой путь получить его в вашем\nрезультирующем дереве - это включить его как внешнюю синтаксическую сущность\n(entity) в преобразование. Это влечет за собой объявление сущности и\nобращение к ней в вашем преобразовании.\n\n**`header.html`:**\n\n```html\n<table>\n  <tr>\n    <td><a href=\"/\">Home</a></td>\n    <td><a href=\"/movies/\">Movies</a></td>\n    <td><a href=\"/shop/\">Shop</a></td>\n  </tr>\n</table>\n```\n\n**`data.xsl`:**\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE xsl:stylesheet [\n<!-- declares header.html as an external parsed entity\n-->\n<!ENTITY header SYSTEM \"header.html\">\n]>\n<xsl:stylesheet version=\"1.0\"\nxmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n    <xsl:template match=\"/\">\n        <html>\n            <head><title>People</title></head>\n            <body>\n            <!-- includes header.html directly -->\n            &header;\n            <xsl:apply-templates />\n            </body>\n        </html>\n    </xsl:template>\n</xsl:stylesheet>\n```\n\nИли у вас есть дополнительные XML-файле, которые вы хотели бы преобразовать и\nвключить в документ, над которым вы работаете.\n\nЕсли у вас есть XML-файл, который вы хотели бы включить в результат, вам нужно\nиспользовать функцию `document()`, чтобы поучить доступ к информации, и вам нужны\nшаблоны в вашем преобразовании, чтобы обработать их и включить в результирующее\nдерево:\n\n**`header.xml`:**\n\n```xml\n<menu>\n    <item href=\"/\">Home</item>\n    <item href=\"/movies/\">Movies</item>\n    <item href=\"/shop/\">Shop</item>\n</menu>\n```\n\n**`data.xsl`:**\n\n```xslt\n<?xml version=\"1.0\"?>\n<xsl:stylesheet version=\"1.0\"\nxmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n    <xsl:template match=\"/\">\n        <html>\n            <head><title>People</title></head>\n            <body>\n                <!-- applies templates to the information contained in\n                header.xml -->\n                <xsl:apply-templates select=\"document('header.xml')\"/>\n\n                <!-- applies templates to the input file -->\n                <xsl:apply-templates />\n            </body>\n        </html>\n    </xsl:template>\n\n    <!-- transforms the XML in header.xml into the table we want -->\n    <xsl:template match=\"menu\">\n        <table>\n            <tr>\n                <xsl:for-each select=\"item\">\n                    <td><a href=\"{@href}\"><xsl:value-of select=\".\"/></a></td>\n                </xsl:for-each>\n            </tr>\n        </table>\n    </xsl:template>\n</xsl:stylesheet>\n```\n\nИли же у вас есть внешние дополнительные XSLT-файлы, которые вы бы хотели\nиспользовать, чтобы формировать результирующее дерево:<br/>\nПусть у вас есть входящий XML-документ, который включает включает некоторую\nинформацию, нужную вам как и остальные данные на странице, вы захотите\nимпортировать (import) или включить (include) преобразования для них, так чтобы\nшаблоны, определённые в них использовались будто они часть основного\nпреобразования. То, что вам нужно: `xsl:import` или `xsl:include` - зависит от того,\nхотите ли вы переопределять шаблоны (или часть из них), которые заданы во\nвключаемом преобразовании. Если хотите, используйте xsl:import, в противном\nслучае - `xsl:include`.\n\n**`data.xml`:**\n\n```xml\n<?xml version=\"1.0\"?>\n<doc>\n    <menu>\n        <item href=\"/\">Home</item>\n        <item href=\"/movies/\">Movies</item>\n        <item href=\"/shop/\">Shop</item>\n    </menu>\n    <people>\n        <person age=\"50\" name=\"larry\"/>\n        <person age=\"50\" name=\"larry\"/>\n    </people>\n</doc>\n```\n\n**`header.xsl`:**\n\n```xslt\n<?xml version=\"1.0\"?>\n<xsl:stylesheet version=\"1.0\"\n  xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n\n  <xsl:template match=\"menu\">\n    <table>\n      <tr>\n        <xsl:for-each select=\"item\">\n          <td><a href=\"{@href}\"><xsl:value-of select=\".\" /></a></td>\n        </xsl:for-each>\n      </tr>\n    </table>\n  </xsl:template>\n\n</xsl:stylesheet>\n```\n\n**`data.xsl`:**\n\n```xslt\n<?xml version=\"1.0\"?>\n<xsl:stylesheet version=\"1.0\"\nxmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n\n  <!-- includes the templates from header.xsl stylesheet -->\n  <xsl:include href=\"header.xsl\" />\n\n  <xsl:template match=\"/\">\n    <html>\n      <head><title>People</title></head>\n      <body>\n\n        <!-- applies templates to the menu definition to create the\n          header - the templates come from header.xsl -->\n        <xsl:apply-templates select=\"doc/menu\" />\n\n        <!-- applies templates to the data to create the rest of the\n          document -->\n        <xsl:apply-templates select=\"doc/people\" />\n\n      </body>\n    </html>\n  </xsl:template>\n  ...\n\n</xsl:stylesheet>\n```\n\nВам также стоит иметь преобразование, включающее шаблоны для видоизменения\nинформации в что-то, что вам нужно.\n\n## Используйте XSL шаблоны проектирования (patterns)\n\n### Метод Кая для нахождения пересечения, разности и дизъюнкции множеств\n\nЕдинственная операция над множествами, предоставляемая XSLT, - это объединение.\nОно может быть описано с использованием оператора объединения из XPath и XSLT -\n\"`|`\". Можно выразить пересечение двух наборов узлов (node set) на чистом XPath.\nЭтот способ был открыт Майклом Каем (Michael Kay) и известен как метод Кая\n(Kaysian method).\n\n```xslt\n<xsl:variable name=\"intersection\" select=\"$ns[count(.|$ns2) = count ($ns2)]\"/>\n\n<xsl:variable name=\"set-difference\" select=\"$ns1[count(.|$ns2) != count($ns2)]\"/>\n```\n\nПример:\n\n```xslt\n<?xml version=\"1.0\"?>\n<xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n                xmlns:data=\"crane\" version=\"1.0\">\n    <xsl:output method=\"text\"/>\n    <data:data> <!--data source for testing purposes-->\n        <item>1</item><item>2</item><item>3</item>\n        <item>4</item><item>5</item><item>6</item>\n    </data:data>\n\n    <xsl:template match=\"/\"> <!--root rule-->\n        <xsl:variable name=\"ns1\" select=\"//item[position()>1]\"/>\n        <xsl:variable name=\"ns2\" select=\"//item[position()&lt;5]\"/>\n\n        <xsl:for-each select=\"$ns1[count(.|$ns2)=count($ns2)]\">\n            Intersection: <xsl:value-of select=\".\"/>\n        </xsl:for-each>\n\n        <xsl:for-each select=\"(\n                        $ns1[count(.|$ns2)!=count($ns2)] |\n                        $ns2[count(.|$ns1)!=count($ns1)]\n                        )\">\n            Difference: <xsl:value-of select=\".\"/>\n        </xsl:for-each>\n    </xsl:template>\n</xsl:stylesheet>\n```\n\nРезультат:\n\n    Intersection: 2\n    Intersection: 3\n    Intersection: 4\n    Difference: 1\n    Difference: 5\n    Difference: 6\n\n### Метод Вендела Пая для нерекурсивного цикла\n\nМетод Вендела Пая (Wendell Pie) демонстрирует способ избежать XSLT-рекурсии при\nприменении циклов.\n\nПример:\n\n```xml\n<Tag ID=\"1\">\n    <Value>4</Value>\n</Tag>\n<Tag ID=\"2\">\n    <Value>2</Value>\n</Tag>\n```\n\nТребующийся результат:\n\n```html\n<table>\n  <tr id=\"1\">\n    <td></td>\n    <td></td>\n    <td></td>\n    <td></td>\n  </tr>\n</table>\n<table>\n  <tr id=\"2\">\n    <td></td>\n    <td></td>\n  </tr>\n</table>\n```\n\nДругими словами, я хочу создать набор новых узлов, количество которых основано\nна значении Value, содержащемся в документе. Ниже я представляю маленькое\nобобщение, которое не зависит от числа узлов в исходном XML-документе и\nиспользует вместо этого число узлов в преобразовании:\n\n```xslt\n<xsl:template match=\"TAG\">\n<TABLE>\n  <TR ID=\"@ID\">\n    <xsl:for-each select=\"(document('')//*)[position() &lt;= Value]\">\n      <TD> </TD>\n    </xsl:for-each>\n  </TR>\n</TABLE>\n</xsl:template>\n```\n\nЗдесь используется количество элементов в преобразовании. Это количество будет\nзначительно превышено, если мы будем проверять на разные типы узлов, например:\n\n```xslt\n<xsl:for-each\n  select=\"($st//node()| $st//@* | $st//namespace::*) [position() &lt;= Value]\">\n```\n\nгде `$st` определено как `document('')`, то есть корневой узел преобразования.\n\n### Метод условной выборки Оливера Беккера\n\nВоможность XPath выбирать список узлов, основываясь на сложных условиях, очень\nмощная. Хотя ей недостаёт возможностей для определения строки как\nпротивоположного набору узлов. Вам часто нужно использовать навороченную\nxsl:choose конструкцию только чтобы определить, что-то вроде \"в случае 1\nиспользуй строку 1, в случае 2 - строку 2, ..., в случае N - строку N.?\n\nВо всех таких случаях нам нужен способ, который позволил бы нам определять в\nXPath-выражении строку, которая зависит от условия или условий.\n\nТеперь о том, как это сделать:<br/>\nМы хотим получить XPath-выражение, которое возвращает строку, когда некоторое\nзаданное условие истинно, и возвращает пустую строку, если это условие ложно.\nМожно условиться, что true - это \"1\", а false - это \"0\". Но как подогнать \"1\" к\nкакой-то строке? Какую функцию для работы со строкой мы могли бы использовать?\n_substring()_ кажется достаточно удобной. А вот и трюк: мы можем\nиспользовать substring() только с двумя аргументами: substring(str, nOffset)\nвозвратит остаток строки str, начинающийся с позиции nOffset.\n\nВ частности:<br/>\n\n- `substring(str, 1)` возвращает целую строку\n- `substring(str, [очень большое число])` возвратит пустую строку, если это\n  большое число гарантированно больше, чем длина строки.\n\nТаким образом, выражение, которое мы могли бы использовать, будет:\n\n```java\nconcat(\n    substring( str1, exp( условие ) ),\n    substring( str2, exp( not(условие) ) )\n)\n```\n\nи мы хотим, чтобы `exp(условие)` было 1, если условие истинное и Infinity, если\nусловие ложное.\n\nМы выражаем exp(условие) так:<br/>\n`1 div условие`, потому что булево значение сначала преобразуется в число (true\n\n- в 1, а false - в 0), мы получим в точности:\n\n```java\nexp(true) = 1\nexp(false) = Infinity\n```\n\nИтог:<br/>\nXPath-выражение, возвращающее одну строку, если условие истинно и другую, если\nоно ложно, такое:\n\n```java\nconcat(\n    substring(Str1, 1 div условие),\n    substring(Str2, 1 div условие)\n)\n```\n\nВпервые это было использовано Оливером Беккером (Oliver Becker) и названо как\nметод Беккера.\n\nНапример:<br/>\nЯ хочу написать темплейт, который создаёт текст: \"My department\", если передан\nпараметр \"IT\" и текст \"Some other department\", если значение параметра другое.\n\nКонечно, никаких `xsl:if` или `xsl:when` не допускается.\n\nПример кода:\n\n```xslt\n<?xml version=\"1.0\"?>\n<xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n                xmlns:data=\"crane\" version=\"1.0\">\n\n  <xsl:output method=\"text\"/>\n\n  <xsl:template match=\"/\">\n    IT:\n    <xsl:call-template name=\"whoIs\">\n      <xsl:with-param name=\"department\" select=\"'IT'\" />\n    </xsl:call-template>\n    <br/>\n    Finance:\n    <xsl:call-template name=\"whoIs\">\n      <xsl:with-param name=\"department\" select=\"'Finance'\" />\n    </xsl:call-template>\n  </xsl:template>\n\n  <xsl:template name=\"whoIs\">\n    <xsl:param name=\"department\" select=\"someDepartment\" />\n    <br/>\n    <xsl:value-of select=\"\n      concat(\n        substring('My department', 1 div ($department = 'IT')),\n        substring('Some other department', 1 div not(($department = 'IT')))\n      )\" />\n    <br/>\n  </xsl:template>\n</xsl:stylesheet>\n```\n\n### Используйте метод Мюнха для группировки\n\nГруппировка часто плохо осуществляется в XSL. Обычно эта задача возникает, когда\nвы получаете XML-вывод (несгруппированный) из базы данных и должны сгруппировать\nего средствами XSL. База данных обычно выдаёт вам результаты, структурированные\nсогласно записям в ней. Например, давайте рассмотрим таблицу служащих, из\nкоторой получается такой XML:\n\n```xml\n<data>\n  <employee no=\"1\">\n    <name>Prathit Bondre</name>\n    <department>IT</department>\n  </employee>\n  <employee no=\"2\">\n    <name>Adheet Bondre</name>\n    <department>Finance</department>\n  </employee>\n  <employee no=\"3\">\n    <name>Sinan Edil</name>\n    <department>IT</department>\n  </employee>\n  <employee no=\"4\">\n    <name>Jeremy King</name>\n    <department>Finance</department>\n  </employee>\n</data>\n```\n\nТребуется такой вывод:\n\n    <strong>Finance</strong>\n    Adheet Bondre\n    Jeremy King\n\n    <strong>IT</strong>\n    Prathit Bondre\n    Sinan Edil\n\nЗадача состоит в том, чтобы превратить этот плоский вывод в список,\nсгруппированный по департаментам, чтобы дать требуемый результат, который\nпоказан выше.\n\nЕсть два шага на пути к решению:\n\n- Узнать, какие департаменты существуют\n- Получить всех служащих, которые относятся к одному департаменту\n\nУзнать, какие департаменты существуют, можно выбрав по одному сотруднику из\nкаждого департамента в XML, который может с успехом быть первым, кто попадётся.\nОдин способ найти их - это взять тех сотрудников, которые не относятся к\nдепартаменту из множества департаментов предыдущих сотрудников.\n\n```xslt\nemployee[not(department = preceding-sibling::employee/department)]\n```\n\nОпределив таких сотрудников, легко найти их департаменты и собрать вместе всех\nсотрудников из одного и того же департамента:\n\n```xslt\n<xsl:apply-template\n  select=\"data/employee[department = current()/department]\"/>\n```\n\nПроблема этого метода в том, что он включает в себя два XPath-выражения,\nвычисление которых потребует много ресурсов для больших XML-документов. Поиск по\nвсем предыдущим братьям с осью 'preceding-sibling' занимает много времени, если\nвы ближе к конце записей. Кроме того, получение всех контактов определённых\nдепартаментов каждый раз включает в себя поиск одного сотрудника.\n\n#### Метод Мюнха\n\nЭтот метод разработан Стивом Мюнхом (Steve Muench) для представления этих\nфункций более эффективным способом с использованием ключей. Ключи работают путём\nназначения значения ключа узлу и дают прямой доступ к узлу через такое значение.\nЕсли элементов, у которых один и тот же ключ, много, то все эти элементы\nнайдутся, когда вы воспользуетесь этим ключом. В сущности, это означает, что\nесли вы хотите сгруппировать множество узлов согласно какому-то свойству узла,\nвы можете использовать ключи.\n\nВ примере выше мы хотим сгруппировать сотрудников согласно их департаментам,\nпоэтому мы создаём ключ, который назначает каждому сотруднику значение ключа,\nкоторое берётся из департамента этого сотрудника. Узлы, которые мы хотим\nсгруппировать должны быть подставлены в атрибут \"match\". Значение ключа, которые\nмы хотим использовать записывается в атрибут \"use\".\n\n```xslt\n<xsl:key name=\"employees-by-department\" match=\"employee\" use=\"department\"/>\n```\n\nОднажды определив ключ, зная департамент, мы можем быстро получить доступ ко\nвсем сотрудникам этого департамента.<br/>\nНапример, ключ `key('employees-by-department', 'IT')` даст записи с\nдепартаментом \"IT\".\n\nОднако, первое, что нам надо сделать,- это определить, какие бывают\nдепартаменты, что включает в себя нахождение первого сотрудника в XML для\nкаждого департамента. Здесь мы снова можем использовать ключи. Мы знаем, что\nсотрудник будет частью списка узлов, которые можно получить по ключу данного\nдепартамента: вопрос в том, будет ли он первым в этом списке (который упорядочен\nкак записи в XML-документе) или ниже? Нас интересуют только записи, идущие\nпервыми в списке.<br/>\nВыяснение, является ли сотрудник первым в списке, возвращённом по ключу,\nподразумевает сравнение узла employee с первым узлом в списке. Этот способ также\nможет быть использован для получения отдельных элементов в XML-файле. Есть пара\nхарактерных способов проверки, идентичны ли два узла:\n\n- Сравнить уникальные идентификаторы, сгенерированные для узлов (используя\n  `generate-id()`):\n\n```xslt\nemployee[generate-id() = generate-id(key('employees-by-department', department)[1])]\n```\n\n- Посмотреть, сколько узлов включает в себя результат объединения двух узлов:\n  один или два - узлы не могут повторяться во множестве, так что если там\n  только один узел, то они должны быть одним и тем же узлом:\n\n```xslt\nemployee[count(.|key('employees-by-department', department)[1]) = 1]\n```\n\nОднажды определив группы, вы можете отсортировать их так, как вам нравится.\nТакже вы можете отсортировать узлы в рамках группы так, как вы хотите. Вот\nшаблон, который создаёт результат, который мы описали, из XML, полученного из\nбазы данных:\n\n```xslt\n<?xml version=\"1.0\"?>\n<xsl:stylesheet version=\"1.0\"\n  xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n\n  <xsl:output method = \"html\" encoding=\"Windows-1252\" />\n  <xsl:key name = \"employees-by-department\" match =\"employee\" use = \"department\" />\n\n  <xsl:template match=\"data\">\n    <html>\n      <head></head>\n      <body>\n        <xsl:for-each select = \"employee[count(.|key('employees-bydepartment',\ndepartment)[1])=1]\">\n          <xsl:sort select=\"department\" />\n          <b><u><xsl:value-of select=\"department\" /></u></b><br/>\n            <xsl:for-each select=\"key('employees-bydepartment',\ndepartment)\">\n              <xsl:sort select=\"name\"/>\n              <xsl:value-of select=\"name\" /><br/>\n            </xsl:for-each>\n          </xsl:for-each>\n        </body>\n      </html>\n  </xsl:template>\n\n</xsl:stylesheet>\n```\n\nМетод Мюнха обычно лучше использовать для группировки узлов из XML-документа,\nпотому что он не подразумевает прохождения через большое число узлов, и поэтому\nон более эффективен. Он особенно полезен, когда у вас есть плоская выдача из\nбазы данных, например, которую вам нужно преобразовать в какую-нибудь\nиерархичную структуру. Он может быть применён в любой ситуации, где нужно\nгруппировать узлы согласно их свойствам, которые можно получить через\nXPath.\n\nОбратная сторона состоит в том, что метод Мюнха будет работать только с\nXSLT-процессором, поддерживающим ключи. Вдобавок, использование ключей может\nбыть достаточно затратным по памяти, потому что все узлы и их ключи хранятся в\nпамяти. Наконец, может быть трудно использовать ключи, если узлы, которые вы\nхотите сгруппировать, получены из разных подключенных источников.\n\n## Использование xsl:import\n\nИспользуйте `<xsl:import>`, чтобы подключить общие, основные правила в\nпреобразование, задуманное для определённых трансформаций. Если можете, не\nимпортируйте больше шаблонов, чем вам нужно.\n\n## Использование статического HTML\n\nДля любых \"неизменных\" порций html на странице (таких как шапка, подвал,\nэлементы навигации) определённо более эффективно хранить фрагменты как внешние\nxml-файлы и копировать их в результирующее дерево используя `xsl:copy-of` и\nфункцию `document()`, чем использовать именованные шаблоны или `xsl:import`.\n\n## Разница между call и apply templates\n\nCall-template, в отличие от aplly-templates, не меняет контекстный (текущий)\nузел. И атрибут select имеет значение только в aplly-templates, и не имеет в\ncall-template.\n\n## Повторное использование кода и рефакторинг\n\nПроблема с использованием одного темплейта с множеством условий - это то, что\nочень быстро делает код отвратительным, нечитаемым и неподддерживаемым. Проблема\nмногих шаблонов состоит в том, что вы часто дублируете код. Золотая середина -\nиспользовать много шаблонов, а при необходимости повторить код - вызывать\nименованные шаблоны, иногда с параметрами, если имеют место небольшие изменения,\nкоторые должны быть учтены. Именованные шаблоны похожи на подпрограммы или\nприватные методы.\n\nНапример. Допустим, вы хотите обработать элементы item, имея один шаблон для\nузлов со значением атрибута type - 'Book', один - для 'CD', и один для всех\nостальных.\n\n```xslt\n<xsl:template match=\"item[@type='Book']\"/>\n<xsl:template match=\"item[@type='CD']\"/>\n<xsl:template match=\"item\"/>\n```\n\nИ они переопределят шаблон, привязанный к \"\\*\" (любой элемент). Шаблоны с более\nточной адресацией будут иметь более высокий приоритет для сопоставления.\n\n##Автоматизируйте XSL-документацию\n\nПрограммисты обычно ненавидят документацию и поэтому обычно не пишут её.\nJavadocs в Java даёт большое утешение программистскому сообществу, обеспечивая\nспособ автоматически генерировать документацию. Есть похожий инструмент, который\nнаписан для XSL и называется xsldoc. Его можно бесплатно скачать на\n[www.xsldoc.org](http://www.xsldoc.org/).\n\nЭтот инструмент обеспечит автоматизированный, стандартизированный и надежный\nспособ создания документации о ваших XSL-файлах, и поскольку он управляется из\nкомандной строки, то может стать частью процесса сборки.\n\n##Не изобретайте велосипед, используйте XSLT-библиотеку\n\nXSLT-библиотека - это open source репозиторий XSL-шаблонов, которые были\nнаписаны и проверены. В библиотеке множество шаблонов для работы со строками,\nдатами, обработки узлов и т.п., что может быть эффективно использовано в ваших\nxsl-файлах. Так что сэкономьте своё время с этой библиотекой. Её можно\nпосмотреть по адресу [http://xsltsl.sourceforge.net](http://xsltsl.sourceforge.net).\n\n## Уменьшайте размер ваших HTML-документов\n\nУменьшайте размер вашего HTML, используя `indent=\"no\"` в теге\n`<xsl:output/>`. Этот атрибут сообщает XSLT-процессору не делать отступы в\nHTML-документе, что делает файлы меньше и они грузятся быстрее.\n\n```xslt\n<xsl:output method=\"html\" indent=\"no\"/>\n```\n","fields":{"slug":"ru/posts/efficient_xslt_techniques/","disqusIdentifier":"ru-issues-efficient_xslt_techniques","readingTime":{"minutes":12.395}},"frontmatter":{"title":"XSLT - результативные технологии программирования","subTitle":null,"date":"25 July 2009","v2":null,"old":true,"tumblr":null,"tags":null,"meta":null,"canonical":null,"cover":null}},"site":{"siteMetadata":{"siteUrl":"https://varya.me"}}},"pageContext":{"slug":"ru/posts/efficient_xslt_techniques/"}},"staticQueryHashes":[],"slicesMap":{}}