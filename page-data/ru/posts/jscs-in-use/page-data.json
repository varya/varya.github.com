{"componentChunkName":"component---src-templates-post-js","path":"/ru/posts/jscs-in-use/","result":{"data":{"mdx":{"id":"92deb8e4-6bb3-5165-8af4-2712f8b90681","body":"\nХочу поделиться опытом поддержания единого стиля JavaScript в одном из своих проектов. Недавно мы решили пробовать\nмолодой инструмент JSCS, и результат его использования понравился всем членам команды.\n<excerpt/>\n\nКогда я присоединилась к проекту [SC5 Styleguide](http://styleguide.sc5.io/), мне сразу бросилось в глаза отсутствие\nединого стиля для JavaScript кода. Это ещё не было ужасающим, но было ясно, что проект в скором времени будет расти и чем раньше мы начнём\nприлагать усилия к соблюдению единого стиля, тем лучше. Тем более, я уже знала о существовании и особенностях JSCS,\nпотому что на одном из моих проектов [публиковался перевод\nстатьи о нем](http://frontendbabel.info/articles/jscs-javascript-code-style/). Поэтому мы даже не стояли перед вопросом,\nкакой инструмент выбрать.\n\nКонечно, есть и другие решения. Чаще всего называют JSLint и JSHint. Но давайте я сначала расскажу вам одну историю.\n\nОказывается, когда авторы JSHint познакомились с JSCS, он им так понравился, что они предпочли стать его\nконтрибьютерами, чем развивать проверку стиля в своём инструменте. А у себя оставили более сложные штуки, не про стиль,\nа про программирование.\n\n<blockquote class=\"twitter-tweet\" lang=\"ru\"><p>And with that, JSCS now has all the style enforcement rules that are\nbeing dropped in <a href=\"https://twitter.com/JSHint\">@JSHint</a> 3.0: <a\nhref=\"https://t.co/W98EMSiTN5\">https://t.co/W98EMSiTN5</a> cc <a\nhref=\"https://twitter.com/valueof\">@valueof</a></p>&mdash; Mike Sherov (@mikesherov) <a\nhref=\"https://twitter.com/mikesherov/status/419596672520318976\">4 января 2014</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nПолучается, выбор стоит не между JSLint, JSHint и JSCS, а между JSLint и комбинацией JSHint + JSCS.\n\n```js\ngulp.task(\"jslint\", [\"jshint\", \"jscs\"]);\n```\n\nА учитывая, что инструмент новый, со стройной архитектурой, контрибьютить в него будет одно удовольствие да и меньше\nшансов на слишком долгую жизнь багов из-за какого-нибудь непроходимого легаси.\n\nВдохновляет также и тот факт, что JSCS уже выбрали такие уважаемые команды как разработчики jQuery, Bootsrap и\nAngularJS.\n\nИтак, JSCS — это npm-пакет, и установить его можно как глобально на свою машину так и локально на конкретный проект:\n\n```\nnpm install jscs\n```\n\nКроме того, понадобится создать конфигурационный файл `.jscsrc` и там описать, какого стиля должен придерживаться\nJavaScript на вашем проекте. Этот файл помещается в корень проекта.\n\nНесмотря на большое количество правил, которые поддерживает JSCS, конфиг вряд ли будет большим, потому что в инструменте\nпредусмотрены пресеты. Популярных стилей для JavaScript кода не так много, и если вы выбрали один из них, то нет нужды\nописывать стиль полностью. Достаточно указать, на кого вы хотели бы быть похожим:\n\n- airbnb\n- crockford\n- google\n- jquery\n- mdcs\n- wikimedia\n- yandex\n\nДаже если у вас есть расхождения с этими стилями, всё равно удобно выбрать максимально похожий пресет, потому что в JSCS\nвозможно переопределить правила пресета.\n\nИ, конечно, важно, что инструмент уже достаточно зрелый. А значит, есть все необходимые дружественные пакеты и плагины\nдля разных редакторов.\n\n## Как это было\n\nВ общем, учитывая все эти факты, мы остановились на JSCS. Начали с того, что написали подходящую нам конфигурацию и тут\nже исключили из списка для проверки все наши файлы. У проекта уже была модульная структура, поэтому это оказалось\nнесложным.\n\n```\n{\n    ...\n\n    \"excludeFiles\": [\n      \"node_modules/**\",\n      \"src/modules/a/**\",\n      \"src/modules/b/**\",\n      \"src/*.js\n    ]\n}\n```\n\nМы договорились, что начиная работать с каким-нибудь модулем, кроме реализации фич, мы также будем править стиль и\nвычеркивать исправленные модули из списка непроверяемых файлов. Соблюдая это, мы довольно быстро исправили все файлы и\nобошлись без конфликтов.\n\nГораздо важнее оказалось поддержание исправленных файлов в их исправленном состоянии во время будуших правок. Конечно,\nтут нам помогают автоматические проверки. Но возникает вопрос, настолько строги мы должны быть в этих проверках и когда\nименно проверять. Ведь поддержка стиля не должна становиться самоцелью и должна перетягивать на себя весь фокус\nразработки.\n\nВ итоге мы пришли к концепции раздения ответственности. Так, для основного репозитория мы выбрали жесткую политику\nв вопросе соблюдения стиля, а для форков — рекомендательную. Мы настроили Travis так, чтобы он проверял стиль для\nпул-реквестов. Если стиль не соблюден, пул-реквест не может быть влит в основной репозиторий. Таким образом, там вообще\nникогда нет кода с плохим стилем. В то же время для форков всё гораздо мягче. Мы отказались от насильственных pre-push\nхуков с проверкой стиля, но рекомендуем самостоятельную установку pre-commit хука и использование плагинов JSCS для\nредакторов, чтобы узнавать об ошибках в процессе разработки, а не тогда, когда ломается пул-реквест. Все рекомендации\nнаписаны у нас в разработческой документации, и новые члены команды активно ими пользуются.\n\nВсем особенно нравится, как реализована поддержка в редакторах. Ведь конфигурация стиля приезжает в репозиторий проекта\nвместе с кодом, и редактор считывает её самостоятельно. А, главное, у разных проектов может быть разный стиль, и для\nперекрестной работы не требуется никакая перенастройка.\n\n![](http://varya.me/jscs-talk/pictures/sublime.gif)\n\nНу и, конечно, всегда есть возможность запустить проверку стиля вручную как gulp-таск.\n\n![](http://varya.me/jscs-talk/pictures/travis.png)\n\n## Предостережения\n\nВо время внедрения инструмента мы столкнулись с парочкой неудобств. Думаю, стоит о них упомянуть, тем более, что к ним\nнашлись решения.\n\nОсновное расстройство — ошибка \"out of memory\" при запуске gulp-таска с проверкой. Оказалось, что недостаточно исключить\nфайлы в конфигурации JSCS. Gulp всё равно сначала пытается работать с ними всеми и пока дело доходит до JSCS, память уже\nкончается. В итоге мы пришли к использованию пакета `gulp-ignore`:\n\n```\ngulp.task('jscs', function() {\n  return gulp.src([\n    '**/*.js'\n  ])\n  .pipe(gulpIgnore.exclude([\n    'node_modules/**',\n    'demo-output/**'\n  ]))\n  .pipe(jscs());\n})\n```\n\nЭто не очень хорошее решение, ведь здесь пришлось перечислить все те исключения, которые уже задекларированы в `.jscsrc`.\nНо лучшего варианта у нас пока нет.\n\nИ, второй момент: если вы используете watch в разработке, то скорее всего захотите видеть ошибки в терминале, но не\nпрерывать исполнение таска. Для этого потребуется `gulp-plumber`:\n\n```\ngulp.task('jscs', function() {\n  return gulp.src([\n    '**/*.js'\n  ])\n  ...\n  .pipe(plumber())\n  .pipe(jscs());\n});\n```\n\nВсё, больше никаких проблем или вопросов относительно иструмента у нас не было. Он прекрасно работает и уже сохранил нам\nтысячи человекочасов.\n\n## А также\n\nВозможно, вас также заинтересует [рассказ автора JSCS](http://habrahabr.ru/post/220229/) и мои\n[слайды](http://varya.me/jscs-talk/) от доклада на эту тему.\n","fields":{"slug":"ru/posts/jscs-in-use/","disqusIdentifier":"posts-jscs-in-use-index-ru","readingTime":{"minutes":4.59}},"frontmatter":{"title":"Использование JSCS","subTitle":null,"date":"25 November 2014","v2":true,"old":null,"tumblr":null,"tags":null,"meta":null,"canonical":null,"cover":null}},"site":{"siteMetadata":{"siteUrl":"https://varya.me"}}},"pageContext":{"slug":"ru/posts/jscs-in-use/"}},"staticQueryHashes":[],"slicesMap":{}}