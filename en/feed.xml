<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title><![CDATA[var ya; stepanova]]></title>
        <description><![CDATA[Front end developer, blogger and cats lover.]]></description>
        <link>http://varya.me/</link>
        <generator>RSS for Node</generator>
        <lastBuildDate>Mon, 19 Jan 2015 14:56:46 GMT</lastBuildDate>
        <atom:link href="http://varya.me//en/feed.xml" rel="self" type="application/rss+xml"/>
        <author><![CDATA[Varya Stepanova]]></author>
        <pubDate>Mon, 19 Jan 2015 14:56:36 GMT</pubDate>
        <item>
            <title><![CDATA[Run on time (about Mac applications)]]></title>
            <description><![CDATA[<p>I use the same laptop for both work and personal needs. This is useful but makes me see to keeping my
work-life balance. I do this simply â€” turn off all the applications running when I finish my working day
in the evening. The only issue is not to forget to open them again next day. But this process can be automatized. :-)</p>
<p><excerpt/>
The most important is to run the applications which are in use by the other team members. For example, I a Jabber app
has to be running since the workday has started. The same goes for any other messenger.</p>
<p>We here at AppGyver use <a href="https://www.flowdock.com">Flowdock</a>
for team communication. So I needed to be sure that it is open every morning.</p>
<p>It turned out that this is doable on Mac with the native Calendar application. Let me show you how exactly.</p>
<h3 id="create-a-new-event-in-the-calendar">Create a new event in the Calendar</h3>
<p>I named mine &quot;Run Flowdock&quot;. Do not bother about the laptop being opened by the event time your are setting up. The
application can run in advance. My event has <code>9:35</code> time.</p>
<h3 id="make-your-event-repeated">Make your event repeated</h3>
<p>This event should be repeated every week at the workdays.</p>
<h3 id="run-the-application">Run the application</h3>
<p>Now the most interesting thing. You can run any application using custom event alerts.</p>
<p>Choose the last item in the <code>alert</code> select, which is <code>Custom</code>.</p>
<p><img
class="article__image"
src="http://img-fotki.yandex.ru/get/4802/14441195.32/0_88921_7d53950e_L.png" width="300" height="500" border="0"
title="" alt=""/></p>
<p>Once the next dialog is opened, choose <code>Open file</code>.</p>
<p><img
class="article__image"
src="http://img-fotki.yandex.ru/get/4813/14441195.32/0_88925_47986a79_M.png" width="300" height="167" border="0"
title="" alt=""/>
<img
class="article__image"
src="http://img-fotki.yandex.ru/get/5109/14441195.32/0_88924_ea39983e_M.png" width="300" height="162" border="0"
title="" alt=""/></p>
<p>By <code>file</code> they mean an applicaiton to be run. It is defined to be <code>Calendar</code> by default but you can
choose another one.</p>
<p><img
class="article__image"
src="http://img-fotki.yandex.ru/get/4810/14441195.32/0_88922_22d155c7_M.png" width="300" height="193" border="0"
title="" alt=""/></p>
<p>Then, select the application needed in the Finder dialog. In my case it is Flowdock.</p>
<p><img
class="article__image"
src="http://img-fotki.yandex.ru/get/4809/14441195.32/0_88923_7597bf28_M.png" width="300" height="196" border="0"
title="" alt=""/></p>
<p>Then, fix the time. 5 minutes before 9:35 is exactly half past nine. Let me remin you, this does not mean that
you need to be at work by this time and have your laptop opened. You can be riding a bus or even sleeping. The
application will run later, when you open your computer.</p>
<h3 id="drawback">Drawback</h3>
<p>Not ideal, indeed. If your calendar is synchronized with iPhone, it peeps by this time. The phone cannot run the
application, so it reminds you about the event with sound. But as <a href="http://varya.me/ru/posts/run-app-in-time-on-mac/#comment-1582219469">one of my friends
suggests</a> the workaround can be to create a
separate calendar for such event and not to synchronize it with other devices.</p>
]]></description>
            <link>http://varya.me//en/posts/run-app-in-time-on-mac</link>
            <guid isPermaLink="true">http://varya.me//en/posts/run-app-in-time-on-mac</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Fri, 12 Sep 2014 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[The so different frontend community and how we deal with it]]></title>
            <description><![CDATA[<p>Long time ago I could read and learn about web development in Russian only. Later, having completed an English language course, I began to read articles and blogs in English more and more. The same went for conferences: I visited
Russian-speaking conferences at first and later switched to English-speaking conferences in Europe. In both articles and conference talks, I noticed how the content was different depending on the language used. Sometime I even thought that the communities evolve in different ways and follow different directions.</p>
<p><excerpt/>
My Russian-speaking colleagues indeed know the &quot;<a href="http://vitaly.harisov.name/article/independent-blocks.html">HTML/CSS markup with independent blocks</a>&quot;
article by Vitaly Harisov. He published
this in 2008 and outlined the main principles of HTML/CSS development which is known as BEM nowadays. We can say
that was the moment BEM started being used in Russia and neighbouring countries. As for English-speaking developers, they
learned about BEM only in 2012 from <a href="http://www.smashingmagazine.com/2012/04/16/a-new-front-end-methodology-bem/">my article in
SmashingMagazine</a>. Then, as you might
know, <a href="http://csswizardry.com/about/">Harry Roberts</a> caught sight
of that and thanks to his publications BEM became known to the rest of the world.</p>
<p>Thus, 4 years passed since the technology was released until a typical English-speaking web developer got a chance to learn about it. This could have been enough time for a technology to mature and slowly die.</p>
<p>No doubt, a better option would be to make it available back in 2008. I suppose that modular trend on the web would have started earlier and we would have got the results faster. Today we
would use Web Components (they implement some component ideas of BEM) everywhere (and for a long time, already).</p>
<p>With all this in mind, I decided to dedicate some of my free time to publish translations on my blog.
So the translated articles on <a href="/en/issues/ym-modular-system">Ymaps modules</a> and
<a href="/en/issues/beml-html-preprocessor">BEML</a> were published. I also had more articles in the queue for translation. Reading
a lot of developer blogs in Russian, I realized that a lot of interesting content is still being produced. &quot;Is this for Russia only?&quot; I asked myself.</p>
<p>Imagine all these new approaches, libraries, and frameworks that exist today all over the world!.. but you will never
learn them because their authors publish in Arabic, Spanish, Japanese or other languages you do not speak.</p>
<p>Nevertheless, we frontend developers have a wonderful community. Open source culture
and technologies like GitHub enable us to help each other and get better results together. To contribute, one does not have to be an expert. For example, many products get their documentation improved just with the help of people who like the project.</p>
<p>This encouraged me to create a collaboration web site for translating frontend articles from local languages into English.</p>
<p>The project is called <strong>Frontend Babel</strong> and here is the URL: <a href="http://frontendbabel.info">http://frontendbabel.info</a>.
Technically, it is a statically generated blog (thanks to DocPad). Any person can take it and run a local copy, then add
a translated article and submit a pull request into the original source.</p>
<ul>
<li><a href="http://frontendbabel.info/about/">About the project</a></li>
<li><a href="https://github.com/frontendbabel/frontendbabel.github.com">Repository on GitHub</a></li>
<li><a href="http://frontendbabel.info/how-to-contribute">How to contribute</a></li>
</ul>
<p>The first couple of articles were already translated by <a href="https://www.google.com/+MaxShirshin">Max Shirshin</a>. These are:</p>
<ul>
<li>an interesting <a href="http://frontendbabel.info/articles/webpage-rendering-101">post about web page rendering by Alexander
Skutin</a></li>
<li>an awesome <a href="http://frontendbabel.info/articles/graphical-interface">article about graphical interface by Danil
Kovchy</a></li>
</ul>
<p>You can already share these links with your English-speaking colleagues :-)</p>
<p>Max and I have plans to translate more during the next weeks. I encourage all of you who knows Arabic, Japanese, Polish, French, Spanish (and any other language) to join the project and help us translate. English-speaking developers can do proofreading.</p>
<p>Translating into a foreign language is hard work indeed, but with the help of English-speaking people in our community, we will get the texts improved. So, if you were thinking about writing in English, this may be a good chance to start and learn.<br/></p>
<p>Interesting articles will attract visitors. With this, both an author and a translator get more attention on the web and establish new proffesional contacts throught their websites and social networks.</p>
<p>Always remember: a contribution to an open source project can be small, but it is always appreciated! Here are just
some ideas on what you can do:</p>
<ul>
<li><a href="https://github.com/frontendbabel/frontendbabel.github.com/issues/new">Add new source articles into our task
queue</a><br/>
If you know an interesting article worth to be published, create an issue about it. So another
contributer can grab this task and translate it.</li>
<li><a href="http://frontendbabel.info/how-to-contribute#push-new-translation">Push new translations</a><br/>
Find a nice article in a language you know, translate it into English and publish on this website.</li>
<li><strong>Tell friends about the project</strong><br/>
Mentioning this project in social networks and your blog posts you can involve people from
all over the world!</li>
<li>Fix English in the texts<br/>
If you spot a grammatical error, you can edit an article (there is a link to an editor below) and submit
a pull request.</li>
<li>Propose site changes<br/>
Suggest what can be improved on this web site by adding your ideas to <a href="https://github.com/frontendbabel/frontendbabel.github.com/issues?labels=%40+Translation&amp;state=open">the list of
issues</a>.</li>
<li><a href="https://github.com/frontendbabel/frontendbabel.github.com/issues?labels=&amp;page=1&amp;state=open">Grab an issue to do</a><br/></li>
</ul>
<p>Your contributions will help improve this project a lot!</p>
]]></description>
            <link>http://varya.me//en/posts/frontend-babel-alpha</link>
            <guid isPermaLink="true">http://varya.me//en/posts/frontend-babel-alpha</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Mon, 30 Jun 2014 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Using side drawers in mobile apps on Steroids.js]]></title>
            <description><![CDATA[<p>As a mobile apps user you may be already familiar to drawers.
They are quite popular solution for a side menu. Using <code>Steroids</code>
HTML5/JavaScript framework for hybrid mobile applications, you
can bring such an interface solution into your product very easy.</p>
<excerpt/>

<p>The usage of drawers explained here is demonstrated in the <a href="https://github.com/AppGyver/kitchensink">Steroids
Kitchensink</a> open source application.
This is now being developed set of most useful examples for Steroids.
As the application is constantly changing, I will freeze the code examples
at <a href="https://github.com/AppGyver/kitchensink/tree/ceacb0ea80799b1d81454e2e966b553b807fbadc">28 May 2014</a>.</p>
<p>To explore the application in your mobile device or in a
simulator clone the repository and run the project. You may need some information
about how to start Steroids projects. That can be learned from tutorials:</p>
<ul>
<li><a href="https://academy.appgyver.com/categories/1-setup-and-getting-started/contents/1-installing-steroids">Installing
Steroids</a></li>
<li><a href="https://academy.appgyver.com/categories/1-setup-and-getting-started/contents/2-hello-world">Hello World application</a></li>
</ul>
<p>Or from my recent article about <a href="/en/posts/html5-mobile-app-width-native-ui/">HTML5 mobile apps with native UI on
Steroids</a>.</p>
<p>Once run the project you will see a page with a list of examples
and a navigation bar.</p>
<p><img class="article__image" src="http://img-fotki.yandex.ru/get/9652/14441195.32/0_8477d_3b6d66a5_L.png" width="282" height="500" border="0"/></p>
<p>The button to teh left of a menu bar opens a side menu. But before we start to
study side drawers let&#39;s look at how this button is shown.</p>
<p>The initial view is coded in <a href="https://github.com/AppGyver/kitchensink/blob/ceacb0ea80799b1d81454e2e966b553b807fbadc/app/views/example/index.html"><code>app/views/example/index.html</code></a>.
This is an angular view with directives for the list and for the navigation bar.</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">ng-controller</span>=<span class="hljs-value">"IndexCtrl"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">navigation-bar</span> <span class="hljs-attribute">title</span>=<span class="hljs-value">"Steroids Kitchensink"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">left-button</span> <span class="hljs-attribute">icon</span>=<span class="hljs-value">"/vendor/icons8/menu-32"</span>
        <span class="hljs-attribute">onTap</span>=<span class="hljs-value">"showMenu()"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">left-button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">navigation-bar</span>&gt;</span>
  ...
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
</code></pre>
<p>The <code>navigation-bar</code> directive is custom and described in <a href="https://github.com/AppGyver/kitchensink/blob/ceacb0ea80799b1d81454e2e966b553b807fbadc/app/directives/navigationBar.coffee"><code>app/directives/navigationBar.coffee</code></a>.
Using such a directive rather than <code>steroids.view.navigationBar</code> helpers at every page is
more useful for the applications with many views.</p>
<p>Indeed inside the directive the same helpers are used. But declaring navigation bar
title and buttons in the view makes our programmers lifes a little bit
easier.</p>
<p>Here the navigation bar titled &quot;Steroids Kitchensink&quot; contains a &quot;hamburger&quot;
menu button which responds to the tapping with calling <code>showMenu</code> methods of
the corresponding controller.</p>
<p>This controller is coded in <a href="https://github.com/AppGyver/kitchensink/blob/ceacb0ea80799b1d81454e2e966b553b807fbadc/app/controllers/example.coffee"><code>app/controllers/example.coffee</code></a>.
As you can see, the <code>showMenu</code> method is pretty short.</p>
<pre class="highlight"><code class="hljs coffeescript">$scope.showMenu = <span class="hljs-function"><span class="hljs-params">()</span>-&gt;</span>
  steroids.drawers.show {
    <span class="hljs-attribute">edge</span>: steroids.screen.edges.LEFT
  }
</code></pre>
<p>It uses the drawers <code>show</code> method and slide the initial view to
the right which uncovers the menu view.</p>
<p>Of course, the code needs to know what is the view we mean by &#39;left&#39;.
We have to provide it with such a knowledge declaring the list of drawers
in the <a href="https://github.com/AppGyver/kitchensink/blob/ceacb0ea80799b1d81454e2e966b553b807fbadc/config/application.coffee#L39"><code>config/application.coffee</code></a>
configuration file.</p>
<pre class="highlight"><code class="hljs coffeescript">steroids.config.drawers =
  <span class="hljs-attribute">left</span>:
    <span class="hljs-attribute">id</span>: <span class="hljs-string">"sidemenu"</span>
    <span class="hljs-attribute">location</span>: <span class="hljs-string">"http://localhost/views/sidemenu/index.html"</span>
    <span class="hljs-attribute">showOnAppLoad</span>: <span class="hljs-literal">false</span>
    <span class="hljs-attribute">widthOfDrawerInPixels</span>: <span class="hljs-number">250</span>
  <span class="hljs-attribute">options</span>:
    <span class="hljs-attribute">centerViewInteractionMode</span>: <span class="hljs-string">"Full"</span>
    <span class="hljs-attribute">closeGestures</span>: [<span class="hljs-string">"PanNavBar"</span>, <span class="hljs-string">"PanCenterView"</span>, <span class="hljs-string">"TapCenterView"</span>]
    <span class="hljs-attribute">openGestures</span>: [<span class="hljs-string">"PanNavBar"</span>, <span class="hljs-string">"PanCenterView"</span>]
    <span class="hljs-attribute">showShadow</span>: <span class="hljs-literal">true</span>
    <span class="hljs-attribute">stretchDrawer</span>: <span class="hljs-literal">true</span>
    <span class="hljs-attribute">widthOfLayerInPixels</span>: <span class="hljs-number">0</span>
</code></pre>
<p>Here the menu view file and some parameters. You can learn about
what they mean from a special tutorial about <a href="https://academy.appgyver.com/categories/3-user-interface-and-design/contents/98-configuring-drawers-on-app-load">configuring drawers</a>.</p>
<p>This will make the sidemenu shown.</p>
<p><img class="article__image" src="http://img-fotki.yandex.ru/get/9766/14441195.32/0_8477e_dbe7889e_L.png" width="282" height="500" border="0"/></p>
<p>To make it look like in the picture you need to provide a
corresponding view with the list of menu items. Here it is defined
in <a href="https://github.com/AppGyver/kitchensink/blob/ceacb0ea80799b1d81454e2e966b553b807fbadc/app/views/sidemenu/index.html"><code>app/views/sidemenu/index.html</code></a>.
This is pretty similar to the list of examples in the initial view. To make it function
we provide:</p>
<ul>
<li>a list of items and the corresponding view in <a href="https://github.com/AppGyver/kitchensink/blob/ceacb0ea80799b1d81454e2e966b553b807fbadc/www/data/sidemenu.json"><code>www/data/sidemenu.json</code></a>;</li>
<li>data model in <a href="https://github.com/AppGyver/kitchensink/blob/ceacb0ea80799b1d81454e2e966b553b807fbadc/app/models/sidemenu.js"><code>app/models/sidemenu.js</code></a>;</li>
<li>controller in <a href="https://github.com/AppGyver/kitchensink/blob/ceacb0ea80799b1d81454e2e966b553b807fbadc/app/controllers/sidemenu.coffee"><code>app/controllers/sidemenu.coffee</code></a>.</li>
</ul>
<p>From the drawers perspective the most important piece of code
to study is the controller. It says to hide the opened drawer if you
tap the currently active menu item. Opening other menu items goes
differently; it replaces the current central view with some animation.</p>
<pre class="highlight"><code class="hljs coffeescript"><span class="hljs-keyword">if</span> item.active
  steroids.drawers.hide {}
<span class="hljs-keyword">else</span>
  webView = <span class="hljs-keyword">new</span> steroids.views.WebView {
    <span class="hljs-attribute">id</span>: item.id,
    <span class="hljs-attribute">location</span>: item.url
  }
  steroids.drawers.hide {
    <span class="hljs-attribute">center</span>: webView
  }
</code></pre>
<p>Hiding the currently opened drawer with <code>steroids.drawers.hide</code> simply
gets back the previously shown central view.</p>
<p>If you want to show a different page, you would also use <code>steroids.drawers.hide</code> but
with an additional <code>center</code> parameter to pass the needed view. This view has to be
created in advance with <code>steroids.views.WebView</code>.</p>
<p>Besides, such a view must be configured as preloaded in <a href="https://github.com/AppGyver/kitchensink/blob/ceacb0ea80799b1d81454e2e966b553b807fbadc/config/application.coffee#L31"><code>config/application.coffee</code></a>.</p>
<pre class="highlight"><code class="hljs coffeescript">steroids.config.preloads = [
  {
    <span class="hljs-attribute">id</span>: <span class="hljs-string">"settings"</span>
    <span class="hljs-attribute">location</span>: <span class="hljs-string">"http://localhost/views/settings/index.html"</span>
  }
]
</code></pre>
<p>Thus, with tapping on the <em>Settings</em> menu item you will get the settings
page shown.</p>
<p><img class="article__image" src="http://img-fotki.yandex.ru/get/9667/14441195.32/0_8477f_2aafe347_L.png" width="282" height="500" border="0"/></p>
<p>This page is empty yet. The upcoming posts will fill it in with something
interesting. Stay tuned :-)</p>
]]></description>
            <link>http://varya.me//en/posts/steroids-drawers</link>
            <guid isPermaLink="true">http://varya.me//en/posts/steroids-drawers</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Mon, 09 Jun 2014 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Docpad with the taste of BEM]]></title>
            <description><![CDATA[<p>Let me present a stub for <strong>docpad-run</strong> project with
<strong>bem-built</strong> static assets. If you ever wanted to be
a generic blog holder equiped with nice and neat static
files, here we go.</p>
<excerpt/>

<h2 id="how-to-start">How to start</h2>
<p>You need install the docpad first. Follow their <a href="http://docpad.org/docs/install">Installation Guide</a>.</p>
<p>Then, the installation of the blog is super short and easy. Clone, fork or
copy from the <a href="https://github.com/varya/docpad-bem-stub">docpad-bem-stub repository</a>.
Then, go though the 3 installation steps:</p>
<pre class="highlight"><code class="hljs bash">npm install
./node_modules/bower-npm-install/bin/bower-npm-install
docpad run
</code></pre>
<p>With these 3 steps you will get:</p>
<ul>
<li>a local server with a generic docpad blog;</li>
<li><a href="http://bem.info/libs/bem-core/2.2.0/">bem-core</a> and <a href="http://bem.info/libs/bem-components/v2/">bem-components</a>
libraries of reusable CSS/JavaScript/templates code;</li>
<li>fully tuned static-build instructions which run on changes
in your source code;</li>
<li>initial blog structure.</li>
</ul>
<h2 id="how-to-write">How to write</h2>
<p>In the given structure you can write either pages or blog posts.
The posts are listed in the index page. Once you added a new
item, you can see it in this list and navigate to its page;
the docpad rebuilds from source automatically.</p>
<p>Place the pages as <code>*.html.md</code> files into <code>src/documents/pages</code>
directory. The posts are kept into <code>src/documents/posts</code>.</p>
<h2 id="how-to-develop-statics">How to develop statics</h2>
<p>The statics is developed with <a href="http://bem.info/">BEM</a>.
You can get CSS and JavaScript files for your pages in
<code>desktop.bundles</code> directory. The pages are built with blocks
from <code>desktop.blocks</code> folder.</p>
<p>The rebuild process for statics runs under docpad server.</p>
<p>Sometimes you may prefer to develop static pages separately.
For this run</p>
<pre class="highlight"><code class="hljs gradle">.<span class="hljs-regexp">/node_modules/</span>enb<span class="hljs-regexp">/bin/</span>enb server
</code></pre><p>You will get another server which rebuilds statics. It
produces static html files from <code>*.bemjson.js</code> files in
<code>desktop.bundles</code>. You can develop the layout inserting
json there and providing <code>BEMHTML</code> templates for the
corresponding block. Find the documentation about <code>BEMHTML</code>
here:</p>
<ul>
<li><a href="http://bem.info/libs/bem-core/2.2.0/templating/intro/">BEMHTML quick start</a></li>
</ul>
<p>For the same blocks you can provide <code>*.css</code> and <code>*.js</code> files
and get them built into pages.</p>
<h2 id="how-to-publish">How to publish</h2>
<p>The blog is tuned to be deployed on GitHub. Thus, your
repository has to be named as <code>&lt;username&gt;.github.com</code>. You
can develop in its <code>source</code> branch. For deploying on
<code>&lt;username&gt;.github.io</code> host run this command:</p>
<pre class="highlight"><code class="hljs bash">docpad deploy-ghpages
</code></pre>
<p>This will create <code>master</code> branch of the repository whose
source is linked to the host.</p>
<p>You can also attach your own domain to the blog like I did.
Also, it is possible to host your blog in differently named
repository. However this will make you to provide changes
on <code>docpad.coffee</code> configuration file.<br/>
Study <a href="https://pages.github.com/">Github Pages</a> to learn more.</p>
<h2 id="why-docpad-">Why Docpad?</h2>
<p>This blog had been running on Jekyll for a while. This was an
acceptable soltuion for a quick start. However with the growth
of the posts base I started to suffer from not very fast
rebuilds. Also, sometimes providing changes into the blog
layout was hard, mostly due to the limitations of <code>liquid</code>
templates.</p>
<p>I&#39;ve decided that <a href="http://docpad.org/">Docpad</a> should be much
better alternative. It is served as an npm package, possible to
be extended with plugins and has an active fast-growing
developers community.</p>
<p>The <code>docpad-bem-stub</code> gives you initial structure, from which
you already can write and publish. If you want to provide changes
into the build process, modify the templates or extend with
plugins, <a href="http://docpad.org/">learn at Docpad website</a>.</p>
<p>Moreover, <a href="http://stackoverflow.com/">Stackoverflow</a> indeed already
has an answer to almost all the questions you have. If not, create a new
one.</p>
<h2 id="why-bem-">Why BEM?</h2>
<p>BEM is a very flexible modular solution for frontend which
enables to develop reusable CSS and JavaScript components. Plus, some code
can be taken from their open source libraries.</p>
<p>You can learn a lot about BEM from <a href="/en/content">my articles and talks</a>
or at the <a href="http://bem.info/">official BEM site</a>.</p>
<h2 id="inside-about">Inside about</h2>
<p>Above I described all you need to know for using your blog. Below there
are a little more technical details on what is behind.</p>
<h3 id="enb">ENB</h3>
<p>I use <a href="https://github.com/enb-make/enb">enb</a> for building pages with block
components. This solution is preferable to bem-tools because of it is much
faster. When rebuilding pages on every change, this is sensetive.</p>
<h3 id="i-bem-js-and-modules">i-bem.js and modules</h3>
<p>I personally love that this solution brings <code>i-bem.js</code> library to the
project. Hope to demonstrate its amazing capabilities here in near future.
But before I stuff my blog with complex JavaScript components, you
can see some examples and very detailed explanations in <a href="http://bem.info/tutorials/bem-js-tutorial/">Step-by-step tutorial on
i-bem.js</a>.</p>
<p>Another JavaScript feature you can enjoy is <a href="/en/issues/ym-modular-system">YM modular system</a>.
These are JavaScript modules with asynchronious resolving.</p>
<h3 id="bemhtml">BEMHTML</h3>
<p>As mentioned above, <code>BEMHTML</code> is a templating solution. Being JavaScript-based,
these templates can be applied on both server and client side. There are
a couple of documents for a deeper dive into it here:</p>
<ul>
<li><a href="http://bem.info/libs/bem-core/2.2.0/templating/rationale/">BEMHTML templates description</a></li>
<li><a href="http://bem.info/libs/bem-core/2.2.0/templating/reference/">BEMHTML tutorial</a></li>
</ul>
<h3 id="bem-core-and-bem-components">bem-core and bem-components</h3>
<p>BEM is also nice for a possibility to borrow the components from libraries.
<code>docpad-bem-stub</code> uses 2 now available libraries:</p>
<ul>
<li><a href="http://bem.info/libs/bem-core/2.2.0/">bem-core</a></li>
<li><a href="http://bem.info/libs/bem-components/v2/">bem-components</a></li>
</ul>
<p>I hope to see more in the future.</p>
<h2 id="what-next-">What next?</h2>
<p>Indeed everything can be improved. These are my thoughts on how
to continue.</p>
<ul>
<li>detect changes in static files<br/>
Docpad watches over the changes in <code>src</code> directory. This means that
when developing statics you will not get the rebuild. I am thinking
on running <code>enb server</code> under <code>docpad run</code> and proxy. This maybe
better than watch over a lot of files in <code>desktop.blocks</code>, <code>desktop.bundles</code>
and all the libraries.</li>
<li>css preprocessors<br/>
The blog styles are in pure CSS now. But with a little
change into enb configuration we can learn it to build with
preprocessors.</li>
<li>fresh design<br/>
Creating a simple layout is the most difficult design task. Don&#39;t you agree?</li>
<li>nice initial posts<br/>
This is even harder than the desing tasks but I think the users feel much
more comfortable when getting a blog with predefined texts.</li>
</ul>
<p>If you feel your oats and want to do your bit, fork <a href="https://github.com/varya/docpad-bem-stub">the repository</a>
and start :-)</p>
]]></description>
            <link>http://varya.me//en/posts/docpad-with-bem-taste</link>
            <guid isPermaLink="true">http://varya.me//en/posts/docpad-with-bem-taste</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Wed, 04 Jun 2014 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[HTML5 mobile apps with native UI on Steroids]]></title>
            <description><![CDATA[<p>Recently I attended <a href="http://2014.front-trends.com/">Front Trends 2014</a> in Warsaw.
This is an awesome conference which you should (no, definitely have to!) attend
in 2015. Besides incredible main programm Front Trends provides a set of Lighting Talks.
This year I was a part of it presenting <a href="http://www.appgyver.com/steroids">Steroids</a>,
a framework and a toolkit for developing HTML5 mobile apps. If you did not have
a chance to hear it, this offline text presentation is for you.<excerpt/></p>
<div class="slide">
  <iframe class="slide__frame" scrolling="no"
    src="http://varya.me/start-with-steroids/?full#Cover">
  </iframe>
</div>

<p>Being an absolute newbie in developing mobile apps I decided to showcase
Steroids because it enables me to create pretty native-looking application
and smoothly go through the developing and releasing flow in a few minutes.</p>
<div class="slide">
  <iframe class="slide__frame" scrolling="no"
    src="http://varya.me/start-with-steroids/?full#summary">
  </iframe>
</div>

<p>The Steroids toolkit is a CLI; it brings Steroids JavaScript framewrok into
your project and takes care of building an app, developing flow, debugging
and releasing. It is based on NodeJs, so you have to have it installed.</p>
<div class="slide">
  <iframe class="slide__frame" scrolling="no"
    src="http://varya.me/start-with-steroids/?full#3">
  </iframe>
</div>

<p>The required version for now is <code>0.10.25</code>. Follow the <a href="http://academy.appgyver.com/categories/1/contents/1">Installation and Setup
Guide</a>.</p>
<div class="slide">
  <iframe class="slide__frame" scrolling="no"
    src="http://varya.me/start-with-steroids/?full#4">
  </iframe>
</div>

<p>Your very first start would be creating a project using <code>steroids create</code>
command. Then, typing <code>steroids connect --watch</code> in the gotten project
folder launches steroids process. The <code>--watch</code> flag as you can guess tells
Steroids to watch over the file changes, rebuild the app and push the results
to the connected devices.</p>
<p>You can connect a physical smartphone to the project. After running
<code>steroids connect</code> you get a web page with a QR code opened in your browser.
Use <code>AppGyver Scanner</code> to read this QR code, it will bring the application
into your phone and keep it connected.</p>
<div style="text-align:center;">
<a href="https://itunes.apple.com/us/app/appgyver-scanner/id575076515?mt=8"
target="_blank"><img alt="Appstore" class="appstore_icon"
src="https://share.appgyver.com/assets/appstore-df950585b54bd081a7826913fc715cd4.png"></a>
<a href="https://play.google.com/store/apps/details?id=com.appgyver.android&amp;feature=nav_result#?t=W251bGwsMSwxLDMsImNvbS5hcHBneXZlci5hbmRyb2lkIl0."
target="_blank"><img alt="Googleplay" class="appstore_icon"
src="https://share.appgyver.com/assets/googleplay-2cef882d62e402fbdbfe8cdac5794069.png"></a>
</div>

<p>Another way to watch the app is to bring it into a desktop simulator.
To do this, type <code>simulator</code> in the terminal wich launched
<code>steroids connect</code>.</p>
<p>You can change the application source files. E.g. edit a text
in <code>www/index.html</code> and make sure that the app in the connected device
or in the simulator has been changed.</p>
<p>To provide more powerful changes you can learn from the examples
and tutorials. Run <code>steroids generate</code> command and get the relevant
code.</p>
<div class="slide">
  <iframe class="slide__frame" scrolling="no"
    src="http://varya.me/start-with-steroids/?full#5">
  </iframe>
</div>

<p>You can learn from this code examples, from <a href="http://academy.appgyver.com/">tutorials</a>
and <a href="http://docs.appgyver.com/en/stable/index.html">API Docs</a>. 
Below I demonstrated some of the features which enable
to use <em>native UI</em>.</p>
<div class="slide">
  <iframe class="slide__frame" scrolling="no"
    src="http://varya.me/start-with-steroids/?full#examples-list">
  </iframe>
</div>

<p>Let us start with showing the native tabs.</p>
<div class="slide">
  <iframe class="slide__frame" scrolling="no"
    src="http://varya.me/start-with-steroids/?full#7">
  </iframe>
</div>

<p>In the <code>config/application.coffee</code> file you can find a commented
example of defining a list of tabs with their icons and
locations (URLs) they lead to.</p>
<p>In my application I created 3 tabs. They are for</p>
<ul>
<li>index.html</li>
<li>notificationExample.html</li>
<li>knowledge.html</li>
</ul>
<pre class="highlight"><code class="hljs coffeescript">steroids.config.tabBar.enabled = <span class="hljs-literal">true</span>
steroids.config.tabBar.tabs = [
  {
    <span class="hljs-attribute">title</span>: <span class="hljs-string">"Index"</span>
    <span class="hljs-attribute">icon</span>: <span class="hljs-string">"icons/pill@2x.png"</span>
    <span class="hljs-attribute">location</span>: <span class="hljs-string">"http://localhost/index.html"</span>
  },
  {
    <span class="hljs-attribute">title</span>: <span class="hljs-string">"Notifications"</span>
    <span class="hljs-attribute">icon</span>: <span class="hljs-string">"icons/bell.png"</span>
    <span class="hljs-attribute">location</span>: <span class="hljs-string">"http://localhost/notificationExample.html"</span>
  },
  {
    <span class="hljs-attribute">title</span>: <span class="hljs-string">"Knowledge base"</span>
    <span class="hljs-attribute">icon</span>: <span class="hljs-string">"icons/coding.png"</span>
    <span class="hljs-attribute">location</span>: <span class="hljs-string">"http://localhost/knowledge.html"</span>
  }
]
</code></pre>
<p>Place the pages into <code>www</code> directory and keep them empty yet.
Do not forget the icons. You can borrow the whole <a href="https://github.com/varya/steroids-fronttrends2014/tree/master/www/icons">icon
folder</a>.</p>
<p>After making the change wait for rebuild and check.</p>
<div style="text-align:center;">
<img src="http://img-fotki.yandex.ru/get/9088/14441195.32/0_84262_ae854cb8_orig.png" width="340" height="89" border="0" title="" alt=""/>
</div>

<p>Next, we can play with notifications.</p>
<div class="slide">
  <iframe class="slide__frame" scrolling="no"
    src="http://varya.me/start-with-steroids/?full#8">
  </iframe>
</div>

<p>Place these buttons inside the <code>&lt;body&gt;</code> container of the
<code>www/notificationExample.html</code> file.</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">button</span>
  <span class="hljs-attribute">class</span>=<span class="hljs-value">"button button-block"</span>
  <span class="hljs-attribute">ontouchend</span>=<span class="hljs-value">"showAlert()"</span>&gt;</span>Show alert dialogue<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">button</span>
  <span class="hljs-attribute">class</span>=<span class="hljs-value">"button button-block"</span>
  <span class="hljs-attribute">ontouchend</span>=<span class="hljs-value">"showConfirm()"</span>&gt;</span>Show confirm dialogue<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">button</span>
  <span class="hljs-attribute">class</span>=<span class="hljs-value">"button button-block"</span>
  <span class="hljs-attribute">ontouchend</span>=<span class="hljs-value">"showPrompt()"</span>&gt;</span>Show prompt dialogue<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">button</span>
  <span class="hljs-attribute">class</span>=<span class="hljs-value">"button button-block"</span>
  <span class="hljs-attribute">ontouchend</span>=<span class="hljs-value">"vibrate()"</span>&gt;</span>Vibrate the device<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
</code></pre>
<p>As you can see, they run different JavaScript functions on
touch. To finish the page you need to define these functions
in the <code>&lt;head&gt;</code> or linked <code>*.js</code> file. Each function demonstrates
a kind of notification which are:</p>
<ul>
<li><code>navigator.notification.alert</code></li>
<li><code>navigator.notification.confirm</code></li>
<li><code>navigator.notification.prompt</code></li>
<li><code>navigator.notification.vibrate</code></li>
</ul>
<p>Borrow the JavaScript code from <a href="https://github.com/varya/steroids-fronttrends2014/blob/master/www/notificationExample.html#L15">my repo</a>.</p>
<p>Now you can navigate to this page using the tabs and try
each type of notification with tapping.</p>
<p>Another native element could be a button in the application navigation
bar.</p>
<div class="slide">
  <iframe class="slide__frame" scrolling="no"
    src="http://varya.me/start-with-steroids/?full#9">
  </iframe>
</div>

<p>The navigation bar can be modified with JavaScript on Steroids.
If you want it to be the same across all the application pages,
provide this JavaScript in the <code>www/javascripts/application.js</code> file
which is linked to all the <code>*.html</code> files.</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">var</span> loginButton = <span class="hljs-keyword">new</span> steroids.buttons.NavigationBarButton();
loginButton.title = <span class="hljs-string">"the Button"</span>;

loginButton.onTap = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    navigator.notification.alert(
        <span class="hljs-string">'You tapped the button!'</span>,
        <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{},
        <span class="hljs-string">'the Alert'</span>,
        <span class="hljs-string">'I did!'</span>
    );
}

steroids.view.navigationBar.update({
    buttons: {
      right: [loginButton]
    }
})
</code></pre>
<p>This will bring the button to the right side of the
navigation bar. Tapping on it you can see a notification; one
of those you studied recently.</p>
<div style="text-align:center;">
<img src="http://img-fotki.yandex.ru/get/9115/14441195.32/0_84264_7f27d435_L.png" width="282" height="500" border="0" title="" alt=""/>
</div>

<p>The last of native UI examples in this app is showing
modal views.</p>
<div class="slide">
  <iframe class="slide__frame" scrolling="no"
    src="http://varya.me/start-with-steroids/?full#10">
  </iframe>
</div>

<p>Add this button into <code>www/index.html</code>:</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">a</span>
  <span class="hljs-attribute">class</span>=<span class="hljs-value">"button button-block"</span>
  <span class="hljs-attribute">ontouchend</span>=<span class="hljs-value">"showModal()"</span>&gt;</span>Open modal<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
</code></pre>
<p>And code <code>showModal</code> method to open a view as a modal.</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showModal</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> webView =
    <span class="hljs-keyword">new</span> steroids.views.WebView(<span class="hljs-string">"/views/modalExample/show.html"</span>);
  steroids.modal.show(webView);
}
</code></pre>
<p>The related view is a piece of html, which you should place into
<code>app/views/modalExample/show.html</code>. BTW, it has to have an interface
element closing the view. To make the process faster, pick up the
<a href="https://github.com/varya/steroids-fronttrends2014/blob/master/app/views/modalExample/show.html">code from the application repo</a>.</p>
<p>With this and <a href="http://docs.appgyver.com/en/stable/steroids_Steroids%20Native%20UI_index.md.html#Steroids%C2%A0Native%C2%A0UI">other UI features</a>
you can build a mobile interface which looks absolutely native for a
device where you application runs.</p>
<p>Once finished coding (or even in process) you may need to show the
application to your friend, client or Mom.</p>
<div class="slide">
  <iframe class="slide__frame" scrolling="no"
    src="http://varya.me/start-with-steroids/?full#sharing">
  </iframe>
</div>

<p>You can use the QR code from the beginning of our session which can
bring your application to any any device directly from your computer.
However this only will work if them both are connected to the same
network.</p>
<p>If you want to share with someone remotely, deploy your app into the cloud.
The <code>steroids deploy</code> command serves for it. As a result you get
a page (also with a QR code) which can be scanned with AppGyver Scaner on
a phone and thus your pal get the same app from the cloud.</p>
<p>All your applications in the cloud can be shared, tuned and built with
web interface at <a href="https://cloud.appgyver.com/applications">cloud.appgyver.com</a>.</p>
<p>From there you also push the app into AppStore and GooglePlay.</p>
<div style="text-align:center;">
<img src="http://img-fotki.yandex.ru/get/9062/14441195.32/0_84265_d03d686e_orig.png" width="500" height="327" border="0" title="" alt=""/>
</div>

<p>This is easy. As easy that a newbie can develop an app in a few minutes
and show you the how-to.</p>
<div class="slide">
  <iframe class="slide__frame" scrolling="no"
    src="http://varya.me/start-with-steroids/?full#links">
  </iframe>
</div>

<p>You can learn more about Steroids and Cordova (Steroids is based on PhoneGap)
at the <a href="http://academy.appgyver.com/">AppGyver Academy</a> where you find:</p>
<ul>
<li>detailed tutorials,</li>
<li>documentation,</li>
<li>big community of devs.</li>
</ul>
<p>And, of course, you can read <a href="/en/posts/">this blog</a>. I promise to share my next findings
regarding Steroids soon :-)</p>
]]></description>
            <link>http://varya.me//en/posts/html5-mobile-app-width-native-ui</link>
            <guid isPermaLink="true">http://varya.me//en/posts/html5-mobile-app-width-native-ui</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Mon, 26 May 2014 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Switching to bem-core#v2]]></title>
            <description><![CDATA[<p>The <code>bem-core</code> library goes futher and there already is <code>2.0.0</code> version
available. This blog was safely switched to the new major version with
<a href="https://github.com/varya/varya.github.com/commit/f21f810b7cb4e16206ef3d088a8b2c38b615f8f3">some diff to the
code</a>.
Now so can do you. Careful examination of the version changelog will help you
with it. Look how I did this.<excerpt/></p>
<p>When a new bem library version is released its changelog is published on the
official BEM website. You can examine the <a href="http://bem.info/libs/bem-core/2.0.0/changelog/">list of changes for bem-core
2.0.0</a>.</p>
<p>The changelog is divided into 3 parts: breaking, marjor and minor changes.</p>
<p>Breaking changes takes most of your attention. As you can see, they declare
removing of some basic methods as well as hosting some code in different
repositories. Thus, if you used some of the listed methods, the switch pushes
you to refactor your code a little bit.</p>
<p>The major changes are less critical but might case some code changes as well. In
this version BEM team provided <a href="https://github.com/bem/bem-core/issues/382">new syntax for defining the blocks in
JavaScript</a>. This change is not
breaking as the old syntax still works. However it is nice to go through a small
refactoring and switch to the new type of module declaration keeping your code
neat for the future.</p>
<p>The same goes for the <a href="https://github.com/bem/bem-core/issues/410">change to DOM
helpers</a>. With getting the context
as a result of using those helpers you can get rid of a couple of lines per
block.</p>
<p>Summing it up, switcing to the new version should be your happiest time as you
have a ready-made excuse to dive into refactoring.</p>
]]></description>
            <link>http://varya.me//en/issues/switching-to-bem-core-2</link>
            <guid isPermaLink="true">http://varya.me//en/issues/switching-to-bem-core-2</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Thu, 15 May 2014 21:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[BEML - an HTML preprocessor for BEM]]></title>
            <description><![CDATA[<p>Depending on a project people prefer different ways to adapt BEM.
This results 
into a range of tools for our choice. Today, I am translating Maxim Shkalin&#39;s
description of the <code>BEML</code> templating pre-processor.</p>
<p>Willing to lighten the development with BEM I propose a tiny extension for the
HTML syntax (yes, I used to writ all those long CSS classes manually). As the
name <code>BEMHTML</code> is greedily taken by the Yandex guys, let us call it <code>BEML</code>.<excerpt/></p>
<h2 id="objective">Objective</h2>
<ol>
<li>Smooth learning curve<br/>
HTML-syntax with no need to transform one language into another.</li>
<li>Portability<br/>
The tool has to be easy to use with other languages.</li>
<li>Compatiblity with template engines<br/>
Instead of trying to replace them.</li>
<li>Simplicity<br/>
Easy to use at any project.</li>
</ol>
<p>It might be my habit, but I do not see the need to transform JSON into HTML.
BEMJSON page description usually looks like spaghetti and is very hard to read
due to its syntax. Also I do not think that HTML is wrong. AngularJS has already
shown that HTML can be much flexible than now. Thus, I decided to follow this
example.</p>
<p>Moreover, there is anothe problem with using BEMHTML. You need Node.js running
for your backend; or use another JavaScript engine for PHP or Rython with dirty
hacks like V8JS or PyV8. The otehr way round could be preparation of a rendered
template, but this sounds even more unnatural.</p>
<p>It would be nice to have a JavaScript-preprocessor and a relative Grunt task
which can be used for creating the prototypes. Then, with transforming to PHP
you can use the same templates in the backend.</p>
<h2 id="concept">Concept</h2>
<p>I had a lot of ideas how to extend HTML with inheritance, includes and loops.
But finally I cut them off. It would be too complex to support and then provide
the portability. Besides, there is a lot of other template engines; I would
rather enter into alliance with them than to compete. Finally I got not a
template engine but a preprocessor (or postprocessor) to the current one.</p>
<p>The scenario is the following. First, create BEML markup using your template
engine. Then, past it not to the client but to the post-processor which turns
BEM syntax into HTML. Funally the HTML goes to the client.</p>
<p>Or, there is a faster way for the braves. You can change your template with
pre-processor which turns BEM attributes into HTML, cache it and use this
chached copy with your dear template engine. Indeed, the pre-processor does not
touch the template engine code.</p>
<h2 id="syntax">Syntax</h2>
<p>This is very simple, you just use 4 more attributes like <code>block</code>, <code>elem</code>, <code>mod</code>
and <code>mix</code>. I suppose it is clear what each of them is responsible for. For the
complex values you can use light JSON dialect with no quotation marks and
optional curly braces. Finally the tool turns this code:</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">block</span>=<span class="hljs-value">"b-animals"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">elem</span>=<span class="hljs-value">"cat"</span> <span class="hljs-attribute">mod</span>=<span class="hljs-value">"size:big, color:red"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
</code></pre>
<p>into the following HTML.</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"b-animals"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"b-animals__cat
              b-animals__cat_size_big
              b-animals__cat_color_red
              "</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
</code></pre>
<p>Much readable.</p>
<p>Full information about the syntax you can learn from the <a href="https://github.com/zenwalker/node-beml">README on GitHub</a>.</p>
<h2 id="try-now">Try now</h2>
<pre class="highlight"><code class="hljs bash">npm install beml
</code></pre>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">var</span> beml = <span class="hljs-built_in">require</span>(<span class="hljs-string">'beml'</span>);
<span class="hljs-keyword">var</span> template = <span class="hljs-string">'&lt;div block="b-block" mod="size:big"&gt;&lt;/div&gt;'</span>;

beml.process(template, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, html)</span> </span>{
  <span class="hljs-built_in">console</span>.log(html);
});
</code></pre>
<h2 id="author">Author</h2>
<p>This article is a translaton.
The original article by Maxim Shkalin was <a href="http://zenwalker.ru/blog/2014/1/html-preprocessor-for-bem.html">posted in his
blog</a>. Follow him in the social networks:
<a class="link social-ico__ico social-ico__ico_in-text social-ico__ico_type_twitter"
href="https://twitter.com/zenwalker2/" target="_blank"></a>
<a class="link social-ico__ico social-ico__ico_in-text social-ico__ico_type_github"
href="https://github.com/zenwalker/" target="_blank"></a></p>
]]></description>
            <link>http://varya.me//en/issues/beml-html-preprocessor</link>
            <guid isPermaLink="true">http://varya.me//en/issues/beml-html-preprocessor</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Thu, 08 May 2014 21:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Borschik helps with remote static assets]]></title>
            <description><![CDATA[<p>Last week I met the need to develop a web site which static assets have to be
hosted on a different server and respond by different URLs than its HTML. This
is the requirement to all the static files: stylesheets and JavaScript linked to
the page as well as imges and fonts mentioned in HTML, CSS and JavaScript
code.<excerpt/> However it is obvious that these resources should be local when developing.
Thus, the challenge was to introduce a piece of magic which knows where we aim
to host the statics and transforms all the relative paths into absolute ones
according to it.</p>
<p>The tools which helped me is called
<a href="http://bem.info/tools/optimizers/borschik/">Borschik</a>. The name is funny.
Besides it reffers to a famous Russian/Ukranian soup, it also alludes to a word
&quot;ÑÐ±Ð¾Ñ€Ñ‰Ð¸Ðº&quot; [sborschik], and so might be translated as</p>
<p><strike>ass</strike>embler. &quot;Removing the ass part&quot; as one of my friends says.
:-)</p>
<center>
<iframe src="//embed.gettyimages.com/embed/135591409?et=B_T3l-shrE-pr9-ELe_wJw&sig=5haG67PAzCxGourA96ZB7m9LwSket1v9PpvXEXNIkBM=" width="508" height="407" frameborder="0" scrolling="no"></iframe>
</center>

<p>In the <a href="https://github.com/varya/st-deliverer">varya/st-deliverer</a> public repository
you can find a stub project illustrating the solution.</p>
<h3 id="project-structure">Project structure</h3>
<p>As you will be able to see later <code>borschik</code> is very flexible. So you can use any
project structure. In my project I store everything in
<a href="b.com/varya/st-deliverer/tree/master/src">src folder</a>.
When building I get HTML files in
<a href="https://github.com/varya/st-deliverer/tree/gh-pages/dist/html">dist/html directory</a>.
Check out the code and make sure that static files are linked from a different
server by their absolute paths.</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>Deliver static assets with Borschik<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">link</span>
      <span class="hljs-attribute">rel</span>=<span class="hljs-value">"stylesheet"</span>
      <span class="hljs-attribute">href</span>=<span class="hljs-value">"http://varya.github.io/stor.../styles.css"</span>/&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">body</span>
    <span class="hljs-attribute">class</span>=<span class="hljs-value">"page"</span>
    <span class="hljs-attribute">background</span>=<span class="hljs-value">"http://varya.github.io/stor.../grungy.jpg"</span>&gt;</span>
  ...
</code></pre>
<p><a href="http://varya.me/st-deliverer/dist/html/">Open in your browser</a> to enjoy my visual
design and a tom-cat.</p>
<h3 id="bring-borschik-to-your-project">Bring borschik to your project</h3>
<p>Borschik is an npm package. So, you can install it globally by runing</p>
<pre class="highlight"><code class="hljs bash">npm install -g borschik
</code></pre>
<p>I personally prefer local project dependencies, so my project has a
<a href="https://github.com/varya/st-deliverer/blob/master/package.json">package.json</a>
file:</p>
<pre class="highlight"><code class="hljs javascript">{
  ...
  <span class="hljs-string">"dependencies"</span>: {
    <span class="hljs-string">"borschik"</span>: <span class="hljs-string">"0.4.2"</span>
  },
  ...
}
</code></pre>
<h3 id="configuration">Configuration</h3>
<p>Before we start the magic transformation it is needed to instruct <code>borschik</code> what
to transform and how to transform. The <a href="https://github.com/varya/st-deliverer/blob/master/.borschik">.borschik</a>
configuration file serves for that.</p>
<pre class="highlight"><code class="hljs javascript">{
  <span class="hljs-string">"paths"</span> : {
    <span class="hljs-string">"src/img/"</span>: <span class="hljs-string">"http://varya.github.io/stor.../st-deliverer/img/"</span>,
    <span class="hljs-string">"src/css/"</span>: <span class="hljs-string">"http://varya.github.io/stor.../st-deliverer/css/"</span>,
    <span class="hljs-string">"src/font/"</span>: <span class="hljs-string">"http://varya.github.io/storage/fonts/"</span>

  }
}
</code></pre>
<p>Note that you can tune different replacements for different paths. Here I tried
to illustrate with the fonts.</p>
<h3 id="run-the-command">Run the command</h3>
<p>Run borschik over a file which contains links to local static assets, and you
will get the transformation result. For example,</p>
<pre class="highlight"><code class="hljs bash">./node_modules/borschik/bin/borschik \
  --input=src/css/styles.css
</code></pre>
<p>Fot the building process you will also need an <code>--output</code> flag to instruct
<code>borschik</code> where to place the result.</p>
<p>Borschik knows the syntax of web technologies. It will not touch the links
mentioned in text, for example.</p>
<h3 id="build-system">Build system</h3>
<p>Now you can use <code>borschik</code> in your project build process. I simply wrote a
<a href="https://github.com/varya/st-deliverer/blob/master/Makefile">Makefile</a> with a
lot of help from <a href="https://github.com/alexeyten">@alexeyten</a> (tnx!).
There is also a grunt plugin <a href="https://github.com/megatolya/grunt-borschik">megatolya/grunt-borschik</a>.<br/>
Indeed, <code>borschik</code> is included into <a href="http://bem.info/tools/bem/bem-tools/">bem-tools</a>
and <a href="https://github.com/enb-make/enb">enb</a> â€” the two competitive solutions for
building the projects with BEM structure.</p>
<h3 id="result">Result</h3>
<p><a href="http://varya.me/st-deliverer/dist/html/">Check the cat again</a>. Still there?</p>
<p>You also can learn about other features of <code>borschik</code> from the article:
<a href="http://bem.info/articles/borschik/">http://bem.info/articles/borschik/</a>.</p>
]]></description>
            <link>http://varya.me//en/issues/borschik-static-assets</link>
            <guid isPermaLink="true">http://varya.me//en/issues/borschik-static-assets</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Wed, 09 Apr 2014 21:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[YM Modular System. Why?]]></title>
            <description><![CDATA[<p>The recently published <a href="http://bem.info/tutorials/articles/bem-js-tutorial/">step-by-step tutorial on
i-bem.js</a> mentioned <strong>YM
modular system</strong> as a base for component JavaScript solution behind BEM. Why do
we need another modular system? Let us see...</p>
<excerpt/>

<p>The author of YM modules, <a href="https://github.com/dfilatov">Dmitry Filatov</a> recently
came up with an <a href="http://habrahabr.ru/post/213627/">article about YM modules</a> in
Russian. And below you can find the translation.</p>
<hr/>

<p>So, one more modular system? Besides CommonJS and AMD? Why should we care?</p>
<p>I will not write why modules and modular systems are needed, there are plenty of
articles about it. Let us rather proceed to the main question: why do we need
<em>another</em> modular system?<br/>
For sure, there are CommonJS and AMD, but working on large projects with them I faced
 large drawbacks. One is that they are synchronous. This is not fatal, but in my
project we often had to provie different hacks for it.</p>
<p>Let us say, we have 3 modules: moduleA, moduleB and moduleC. moduleC depends on
both moduleA and moduleB. Initially I will describe this in code for all the
three solutions:</p>
<h4 id="commonjs">CommonJS</h4>
<p><em>moduleA.js:</em></p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = <span class="hljs-string">'A'</span>;
</code></pre>
<p><em>moduleB.js:</em></p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = <span class="hljs-string">'B'</span>;
</code></pre>
<p><em>moduleC.js:</em></p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">var</span> moduleA = <span class="hljs-built_in">require</span>(<span class="hljs-string">'A'</span>); 
    moduleB = <span class="hljs-built_in">require</span>(<span class="hljs-string">'B'</span>);

<span class="hljs-built_in">module</span>.exports = moduleA + moduleB + <span class="hljs-string">'C'</span>;
</code></pre>
<p><em>Linking and usage:</em></p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">var</span> moduleC = <span class="hljs-built_in">require</span>(<span class="hljs-string">'C'</span>);
<span class="hljs-built_in">console</span>.log(moduleC); <span class="hljs-comment">// prints "ABC"</span>
</code></pre>
<h4 id="amd">AMD</h4>
<p><em>moduleA.js:</em></p>
<pre class="highlight"><code class="hljs javascript">define(<span class="hljs-string">'A'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'A'</span>;
});
</code></pre>
<p><em>moduleB.js:</em>:</p>
<pre class="highlight"><code class="hljs javascript">define(<span class="hljs-string">'B'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'B'</span>;
});
</code></pre>
<p><em>moduleC.js:</em></p>
<pre class="highlight"><code class="hljs javascript">define(<span class="hljs-string">'Ð¡'</span>, [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(moduleA, moduleB)</span> </span>{
    <span class="hljs-keyword">return</span> moduleA + moduleB + <span class="hljs-string">'C'</span>;
});
</code></pre>
<p><em>Linking and usage:</em></p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-built_in">require</span>([<span class="hljs-string">'Ð¡'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(moduleC)</span> </span>{
    <span class="hljs-built_in">console</span>.log(moduleC); <span class="hljs-comment">// prints "ABC"</span>
});
</code></pre>
<h4 id="ym">YM</h4>
<p><em>moduleA.js:</em></p>
<pre class="highlight"><code class="hljs javascript">modules.define(<span class="hljs-string">'A'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(provide)</span> </span>{
    provide(<span class="hljs-string">'A'</span>);
});
</code></pre>
<p><em>moduleB.js:</em></p>
<pre class="highlight"><code class="hljs javascript">modules.define(<span class="hljs-string">'B'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(provide)</span> </span>{
    provide(<span class="hljs-string">'B'</span>);
});
</code></pre>
<p><em>moduleC.js:</em></p>
<pre class="highlight"><code class="hljs javascript">modules.define(<span class="hljs-string">'C'</span>, [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(provide, moduleA, moduleB)</span> </span>{
    provide(moduleA + moduleB + <span class="hljs-string">'C'</span>);
});
</code></pre>
<p><em>Linking and usage:</em></p>
<pre class="highlight"><code class="hljs javascript">modules.require([<span class="hljs-string">'Ð¡'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(moduleC)</span> </span>{
    <span class="hljs-built_in">console</span>.log(moduleC); <span class="hljs-comment">// prints "ABC"</span>
});
</code></pre>
<p>Nothing interesting yet. All three examples are similar, although you may
notice the <code>provide</code> callback in the YM example. What is it for?</p>
<p>Let us imagine a case that <code>moduleA</code> and <code>moduleB</code> cannot be resolved immediately
(synchronously, as it is required by CommonJS and AMD). Sometimes you need to
do an asynchronous action first. The simpliest example can be <code>setTimeout</code>.
There is no way to implement it elegantly with CommonJS and AMD.
But with <code>YM</code> it can be coded as follows:</p>
<p><em>moduleA.js:</em></p>
<pre class="highlight"><code class="hljs javascript">modules.define(<span class="hljs-string">'A'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(provide)</span> </span>{
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        provide(<span class="hljs-string">'A'</span>);
   });
});
</code></pre>
<p><em>moduleB.js:</em></p>
<pre class="highlight"><code class="hljs javascript">modules.define(<span class="hljs-string">'B'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(provide)</span> </span>{
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        provide(<span class="hljs-string">'B'</span>);
    });
});
</code></pre>
<p><em>moduleC.js:</em></p>
<pre class="highlight"><code class="hljs javascript">modules.define(<span class="hljs-string">'C'</span>, [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(provide, moduleA, moduleB)</span> </span>{
    provide(moduleA + moduleB + <span class="hljs-string">'C'</span>);
});
</code></pre>
<p>Interestingly <code>moduleC</code> does not know anything about asynchronous actions in
its dependant modules. <em>Win!</em></p>
<h3 id="real-life-example">Real life example</h3>
<p>As for real file example, I often use the YandexMaps API
(<a href="http://api.yandex.com/maps/">http://api.yandex.com/maps/</a>, API of
<a href="http://maps.yandex.com/">Yandex.Maps</a>
public service). Yandex.Maps API has a complex loading scheme and this cannot be
done synchronously. This means that I cannot simply link it to a page
<code>&lt;script type=&quot;text/javascript&quot; src=&quot;url-of-ymaps.js&quot;&gt;&lt;/script&gt;</code> and be sure that
all the following scripts will get the API code ready. First I need to wait for
the event <code>ymaps.ready</code> to fire.</p>
<p>The project I am working for is quite complex; we have many classes inherited
from the basic API. For example, we have a <code>ComplexLayer</code> class based on <code>ymaps.Layer</code>.
With YM modules it is simple to implement. We define a <code>ymaps</code> module which loads
the API code, waits for the <code>ymaps.ready</code> event and then provides itself. All
the modules which have the <code>ymaps</code> module as a dependency only start to resolve 
after this. As you can see, other modules know nothing about the asynchronicity of the
Yandex.Map API. <em>No hacks in code!</em></p>
<p><em>ymaps.js:</em></p>
<pre class="highlight"><code class="hljs javascript">modules.define(
    <span class="hljs-string">'ymaps'</span>,
    [<span class="hljs-string">'loader'</span>, <span class="hljs-string">'config'</span>],
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(provide, loader, config)</span> </span>{

    <span class="hljs-keyword">var</span> url = config.hosts.ymaps + <span class="hljs-string">'/2.1.4/?lang=ru-RU'</span> +
              <span class="hljs-string">'&amp;load=package.full&amp;coordorder=longlat'</span>;

    loader(url, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        ymaps.ready(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
            provide(ymaps);
        });
    });
});
</code></pre>
<p>There are 2 other modules in use here: <code>loader</code> and <code>config</code>. I do not show
their code, but the first one loads scripts and the second one is a hash with
constant values.</p>
<p><em>ComplexLayer.js:</em></p>
<pre class="highlight"><code class="hljs javascript">modules.define(<span class="hljs-string">'ComplexLayer'</span>, [<span class="hljs-string">'inherit'</span>, <span class="hljs-string">'ymaps'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(provide, inherit, ymaps)</span> </span>{
    <span class="hljs-keyword">var</span> ComplexLayer = inherit(ymaps.Layer, ...);

    provide(ComplexLayer);
});
</code></pre>
<p>We can do the same if jQuery is needed. There is a module to load jQuery:</p>
<pre class="highlight"><code class="hljs javascript">modules.define(
    <span class="hljs-string">'jquery'</span>,
    [<span class="hljs-string">'loader'</span>,
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(provide, loader)</span> </span>{

    loader(<span class="hljs-string">'//yandex.st/jquery/2.1.0/jquery.min.js'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        provide(jQuery.noConflict(<span class="hljs-literal">true</span>));
    });
});
</code></pre>
<p>Then we make other modules dependent on <code>jquery</code> module.</p>
<p>Thus, the whole project code is represented with modules. There is no global, no
need for agreement on the order of linking the scripts (including third-party ones),
no dirty hacks for asynchronicity.</p>
<p>And to wrap up, let me demonstrate you the YM modular system API (indeed, it has more
methods, and these are only the basic ones).</p>
<p><em>Defining a module:</em></p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">void</span> modules.define(
    <span class="hljs-built_in">String</span> moduleName,
    [<span class="hljs-built_in">String</span>[] dependencies],
    <span class="hljs-built_in">Function</span>(
        <span class="hljs-built_in">Function</span>(<span class="hljs-built_in">Object</span> objectToProvide) provide,
        [<span class="hljs-built_in">Object</span> resolvedDependency, ...],
        [<span class="hljs-built_in">Object</span> previousDeclaration]
    ) declarationFunction
)
</code></pre>
<p><em>Requiring a module:</em></p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">void</span> modules.require(
    <span class="hljs-built_in">String</span>[] dependencies,
    <span class="hljs-built_in">Function</span>(
        [<span class="hljs-built_in">Object</span> resolvedDependency, ...]
    ) callbackFunction
)
</code></pre>
<p>The project is open source and hosted at GitHub:
<a href="https://github.com/ymaps/modules">github.com/ymaps/modules</a>.</p>
]]></description>
            <link>http://varya.me//en/issues/ym-modular-system</link>
            <guid isPermaLink="true">http://varya.me//en/issues/ym-modular-system</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Mon, 24 Mar 2014 22:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[JavaScript in BEMJSON]]></title>
            <description><![CDATA[<p>We usually start developing a web site prototyping the interface and then
implementing HTML/CSS and bacis JavaScript. In case
of using the full BEM stack a tranformation from prototype to a functioning web
site goes smoothly. You can clone the project from
<a href="https://github.com/bem/project-stub">project-stub</a> and create a static web page
as it was <a href="http://bem.info/articles/start-with-project-stub/">described
earlier</a>.</p>
<excerpt/>

<p>Thanks to <code>BEMHTML</code> templates, you do not need write all the HTML manually.
Describing page sructure in <code>BEMJSON</code> rather than writing all the tags manually
saves time. But sometimes this is still a lot of work to do, especially for large
pages.</p>
<p>Luckily BEMJSON can include JavaScript pieces to produce some blocks dymamically.
I created an example of such usage:</p>
<pre class="highlight"><code class="hljs javascript">({
    block: <span class="hljs-string">'page'</span>,
    ...
    content:[
        ...
        {
            block: <span class="hljs-string">'content'</span>,
            content: (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">var</span> res = [];
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
                    res.push({
                        block: <span class="hljs-string">'button'</span>,
                        content: <span class="hljs-string">'Button '</span> + (i + <span class="hljs-number">1</span>)
                    });
                }
                <span class="hljs-keyword">return</span> res;
            })()
        },
        ...
    ]
})
</code></pre>
<p><a href="https://github.com/varya/dynamic-bemjson/blob/master/desktop.bundles/page1/page1.bemjson.js">full
code</a></p>
<p>This JavaScript creates 10 <code>button</code> blocks when the page is being built with
<code>bem-tools</code>.
Check the <a href="http://varya.me/dynamic-bemjson/desktop.bundles/page1/page1.html">result
page</a>
to see them.</p>
<p>Another example is a <code>menu</code> block. Such interface pieces usually consist of a
lot of items with minor differences which cases a lot of copy-paste on a page.
With JavaScript in BEMJSON this can be easily reduced.</p>
<pre class="highlight"><code class="hljs javascript">({
    block: <span class="hljs-string">'page'</span>,
    ...
    content:[
        ...
        {
            block: <span class="hljs-string">'menu'</span>,
            content: [
                {
                    title: <span class="hljs-string">'Index'</span>,
                    isSelected: <span class="hljs-literal">false</span>,
                },
                {
                    title: <span class="hljs-string">'Products'</span>,
                    isSelected: <span class="hljs-literal">true</span>
                },
                {
                    title: <span class="hljs-string">'Contact'</span>,
                    isSelected: <span class="hljs-literal">false</span>
                }
            ].map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span></span>{
                <span class="hljs-keyword">var</span> block = {
                    block: <span class="hljs-string">'menu'</span>,
                    elem: <span class="hljs-string">'item'</span>,
                    content: item.title,
                    mods: {
                        selected: item.isSelected
                    }
                };
                <span class="hljs-keyword">return</span> block;
            })
        },
        ...
    ]
})
</code></pre>
<p><a href="https://github.com/varya/dynamic-bemjson/blob/master/desktop.bundles/page2/page2.bemjson.js">full
code</a></p>
<p>This gives a <a href="http://varya.me/dynamic-bemjson/desktop.bundles/page2/page2.html">page with a menu of 3 items</a>.
The bigger is the array of items, the more you save. Especially when the structure
of every item changes while developing.</p>
<p>Indeed, this feature is not needed when BEMJSON is a result of 1st layer templates
(like BEMTREE, priv.js) you can produce as much BEMJSON as is necessary. But with
initial development of a static web page, the JavaScript tricks help to avoid
copy-paste.</p>
]]></description>
            <link>http://varya.me//en/issues/javascript-in-bemjson</link>
            <guid isPermaLink="true">http://varya.me//en/issues/javascript-in-bemjson</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Thu, 20 Feb 2014 22:00:00 GMT</pubDate>
        </item>
    </channel>
</rss>