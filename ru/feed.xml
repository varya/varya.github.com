<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title><![CDATA[var ya; stepanova]]></title>
        <description><![CDATA[Front end developer, blogger and cats lover.]]></description>
        <link>http://varya.me/</link>
        <generator>RSS for Node</generator>
        <lastBuildDate>Wed, 25 Nov 2015 12:37:12 GMT</lastBuildDate>
        <atom:link href="http://varya.me//ru/feed.xml" rel="self" type="application/rss+xml"/>
        <author><![CDATA[Varya Stepanova]]></author>
        <pubDate>Wed, 25 Nov 2015 12:36:16 GMT</pubDate>
        <item>
            <title><![CDATA[Стайл гайд для самых маленьких]]></title>
            <description><![CDATA[<p>В этом году у меня было несколько презентаций про <a href="http://styleguide.sc5.io/">SC5 Style Guide</a>, в которых
я делилась опытом использования инструмента на проектах одного их наших клиентов — мобильного оператора Elisa.
Учитывая, что Elisa — огромная компания с массой вебсайтов, на которых нужно поддерживать единый стиль, не
удивительно, что SC5 Style Guide как инструмент там очень полезен. Но как насчет небольших проектов? Стоит ли для них
делать стайл гайды? Я сама не знала ответ на этот вопрос и захотела поэкспериментировать. В качестве подопытного
сайта взяла собственный блог.</p>
<excerpt/>

<p>Живой стайл гайд моего блога выглядит вот так: <a href="http://varya.me/styleguide">varya.me/styleguide</a>. Вы можете видеть
весь интерфейс, разделенный на блоки, каждый из которых подразумевает самостоятельный компонент. Я до сих пор не
смотрела на интерфейс своего блога в таком ключе, и это заставляет меня даже пересмотреть CSS-архитектуру проекта. Но
давайте обо всём по порядку.</p>
<h2 id="-sc5-style-guide">Настройка SC5 Style Guide</h2>
<p>Всё начинается с установки пакета</p>
<pre class="highlight"><code class="hljs q">npm install --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> sc5-styleguide
</code></pre><p>После этого я смогла сгенерировать веб-сайт стайл гайда. Для этого понадобилась
<a href="https://github.com/varya/varya.github.com/blob/af38b1fb0bd6e5a1b043d002ad5dbf107f17e6c1/Gulpfile.js">парочка gulp тасков</a>.</p>
<p>Мне нужно было немного отступить от конфигурации, которая предлагается в документации, чтобы решить свои задачи. Напишу
об этом подробно.</p>
<h3 id="-approot-">Использование параметра <code>appRoot</code></h3>
<p>Мой стайл гайд находится не в корне домена, а в папке, которая называется <code>styleguide</code>. Об этом нужно сообщить
инструменту, чтобы сгенерированное им приложение использовало верные ссылки:</p>
<pre class="highlight"><code class="hljs javascript">gulp.task(<span class="hljs-string">"styleguide:generate"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{

  <span class="hljs-keyword">return</span> gulp.src([<span class="hljs-string">"desktop.blocks/**/*.css"</span>])
    .pipe(styleguide.generate({
      title: <span class="hljs-string">"Varya.me Styleguide"</span>,
      appRoot: <span class="hljs-string">'/styleguide'</span>,
      ...
</code></pre>
<h3 id="-javascript">Подключение JavaScript</h3>
<p>В качестве значения параметра <code>extraHead</code> можно перечислить все, что нужно подключить к странице. У меня для некоторых
компонент требуется JavaScript. Конечно, не обязательно делать так, чтобы он работал, можно просто делать стайл гайд
только на базе CSS. Но мне хотелось, чтобы компоненты в документации выглядели бы абсолютно так же как в блоге. И
благодаря <code>extraHead</code> я могу указать, какой JavaScript файл нужен.</p>
<pre class="highlight"><code class="hljs javascript">gulp.task(<span class="hljs-string">"styleguide:generate"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{

  <span class="hljs-keyword">return</span> gulp.src([<span class="hljs-string">"desktop.blocks/**/*.css"</span>])
    .pipe(styleguide.generate({
      title: <span class="hljs-string">"Varya.me Styleguide"</span>,
      ...
      extraHead: [
        <span class="hljs-string">'&lt;script src="http://yandex.st/jquery/1.7.2/jquery.min.js"&gt;&lt;/script&gt;'</span>,
        <span class="hljs-string">'&lt;script src="/desktop.bundles/index/index.min.js"&gt;&lt;/script&gt;'</span>,
        ...
      ]
    ...
</code></pre>
<p>Но на самом деле нужна ещё одна хитрость. Мои компоненты написаны на <code>i-bem.js</code> и автоматически инициализируются по
<code>domReady</code>. Это как раз то что нужно для блога, ведь страницы статические и вся HTML-разметка сразу загружается. Но сайт
стайл гайда — это SPA (одностраничное приложение), и там это не работало. Компоненты отрисовываются на страницах
стайлгайда &quot;на лету&quot;, и очевидно, что это происходит позже <code>domReady</code>. То есть они не инициализируются автоматически.
К счастью, можно использовать событие <code>styleguide:onRendered</code> на объекте <code>window</code>, которое SC5 Style Guide создаёт
каждый раз, когда компонент перересовывается. Я сделала инициализацию компонент на это событие, то есть сразу после того
как они появляются на странице. Такая инициализация нужна только на сайте стайл гайда, поэтому этот код не включается
в общую сборку и подключается к стайл гайду как дополнительный файл.</p>
<pre class="highlight"><code class="hljs r">gulp.task(<span class="hljs-string">"styleguide:generate"</span>, <span class="hljs-keyword">function</span>() {

  <span class="hljs-keyword">return</span> gulp.src([<span class="hljs-string">"desktop.blocks/**/*.css"</span>])
    .pipe(styleguide.generate({
      title: <span class="hljs-string">"Varya.me Styleguide"</span>,
      <span class="hljs-keyword">...</span>
      extraHead: [
        <span class="hljs-keyword">...</span>
        <span class="hljs-string">'&lt;script src="/styleguide/i-bem__init_styleguide.js"&gt;&lt;/script&gt;'</span>
      ]
    <span class="hljs-keyword">...</span>
</code></pre><p>Вы можете посмотреть, как работают компоненты с JavaScript на примере блока, который показывает список репозиториев
на GitHub после того как сделает запрос в GitHub API:
<a href="http://varya.me/styleguide/#/section/4.3">varya.me/styleguide/#/section/4.3</a>. Или на странице блока с кружочками,
которые генерируются случайным образом: <a href="http://varya.me/styleguide/#/section/5.1">varya.me/styleguide/#/section/5.1</a>.</p>
<p>И последняя, очень важная деталь для того, чтобы заставить JavaScript работать — это использование параметра
<code>disableEncapsulation: true</code>. По умолчанию Style Guide оборачивает каждый компонент в ShadowDOM. Это даёт разработчику
возможность не беспокоиться о том, что его стили пересекутся со стилями сгенерированного веб-сайта. Но в то же время
это инкапсулирует компонент, в том числе и от JavaScript, подключённого в <code>&lt;head&gt;</code>. Но благодаря специальному параметру
эту инкапсуляцию можно предотвратить. Так что у меня компоненты просто вставляются в HTML-код сайта как есть. Что
касается возможности перезаписать стили сайта, этого не случится. Я использую БЭМ, поэтому все компоненты уже
&quot;инкапсулированы&quot; на уровне методологии.</p>
<h3 id="-">Стайл гайд как статическая страница</h3>
<p>Для режима разработки у SC5 Style Guide запускается сервер, который разруливает все пути в корневой каталог, откуда и
раздаётся сгененированный SPA-сайт. Если вы хотите пользоваться результатом в своём сервере, о такой маршрутизации
придется позаботиться самостоятельно. Но в моём случае сайт располагается на GitHub Pages, это статический хостинг и там
никакой маршрутизации не предусмотрено. Однако на этот случай есть настройка <code>disableHtml5Mode: true</code>. Она говорит
генератору, что в приложении должны быть старые добрые ссылки с решеткой <code>#</code>. Так что всё работает.</p>
<h2 id="-">Документирование компонент</h2>
<p>Ещё до внедрения стайл гайда, у меня весь CSS был написан по БЭМ, то есть с компонентым подходом. Для стайл гайда нужно
было только задать компонентам структуру и задокументировать блоки при помощи KSS.</p>
<h3 id="-">Структурирование кода</h3>
<p>Оказалось, что файловая структура, которую предлагает БЭМ, не самое лучшее решение для разработки живого стайлгайда. На
файловой системе все компоненты представлены длинным плоским списком:</p>
<pre class="highlight"><code class="hljs r">desktop.blocks/
├── article
├── articles-list
├── box
├── <span class="hljs-keyword">...</span>
└── text
</code></pre><p><a href="https://github.com/varya/varya.github.com/tree/af38b1fb0bd6e5a1b043d002ad5dbf107f17e6c1/desktop.blocks">github/varya/varya.github.com/desktop-blocks</a></p>
<p>То есть маленькие атомарные компоненты никак не отличаются от блоков для структуры страницы (таких как Header или
Footer), от блоков из сайдбара или от CSS для сторонних виджетов. Разумеется, плоская структура более удобна для
сборщиков, но с точки зрения разработки нужна какая-то каталогизация.</p>
<p>Для этого я сделала файл <code>overview.css</code>, в котором нет никакого активного CSS, но он помогает мне организовать блоки.
У меня там 5 секций, и в каждой относящиеся к ней компоненты:</p>
<pre class="highlight"><code class="hljs r">/*
Atoms

Styleguide <span class="hljs-number">1</span>

styleguide:ignore:start

@import url(<span class="hljs-string">"logo/logo.css"</span>); // <span class="hljs-number">1.1</span>
@import url(<span class="hljs-string">"text/text.css"</span>); // <span class="hljs-number">1.2</span>
<span class="hljs-keyword">...</span>

styleguide:ignore:end
*/

/*
Main blocks

Styleguide <span class="hljs-number">2</span>

styleguide:ignore:start

@import url(<span class="hljs-string">"header/header.css"</span>); // <span class="hljs-number">2.1</span>
<span class="hljs-keyword">...</span>

styleguide:ignore:end
*/
</code></pre><p><a href="https://github.com/varya/varya.github.com/blob/af38b1fb0bd6e5a1b043d002ad5dbf107f17e6c1/desktop.blocks/overview.css">github/varya/varya.github.com/desktop-blocks/overview.css</a></p>
<p>По сути в файле кроме комментариев ничего нет. А в комментариях — описание каждой секции. Также перечислены
файлы блоков, имеющие к ней отношение. Это удобно для навигации по коду. В этом перечислении я использовала <code>@import</code>
(просто потому что могу).</p>
<p>Здесь только одна особенность — использование волшебных комментариев <code>styleguide:ignore:start</code> и
<code>styleguide:ignore:end</code>. Ими можно обернуть любой кусок CSS (SASS или LESS) кода и таким образом сказать генератору SC5
Style Guide, что этот кусок нужно проигнорировать.</p>
<p>Я игнорирую свои списки блоков, потому что они никак не влияют на код. Но описания секций остаются.</p>
<h3 id="-">Описание блоков</h3>
<p>Все остальное легко. Перед каждым компонентом я размещаю комментарий с KSS описанием. Например, один из простых блоков,
Logo:</p>
<pre class="highlight"><code class="hljs css"><span class="hljs-comment">/*

Logo

markup:
&lt;logo class="logo"&gt;···&lt;b class="var"&gt;var&lt;/b&gt;·&lt;b class="ya"&gt;ya&lt;/b&gt;;&lt;b class="cursor"&gt;&lt;/b&gt;&lt;/logo&gt;

Styleguide 1.1

*/</span>
<span class="hljs-class">.logo</span>
<span class="hljs-rules">{
<span class="hljs-rule"><span class="hljs-attribute">...
</span></span></span></code></pre>
<p><a href="https://github.com/varya/varya.github.com/blob/af38b1fb0bd6e5a1b043d002ad5dbf107f17e6c1/desktop.blocks/logo/logo.css">github/varya/varya.github.com/desktop-blocks/logo/logo.css</a></p>
<p>See it rendered: <a href="http://varya.me/styleguide/#/section/1.1">varya.me/styleguide/#/section/1.1</a></p>
<p>В некоторых компонентах использованы дополнительные возможности. Например, социальные иконки — это один и тот же блок
с разными модификаторыми. Такое можно задокументировать одним махом:</p>
<pre class="highlight"><code class="hljs css"><span class="hljs-comment">/*
Social icon

.social-ico__ico_type_rss         - RSS
.social-ico__ico_type_twitter     - Twitter
.social-ico__ico_type_github      - Github
.social-ico__ico_type_facebook    - Facebook
.social-ico__ico_type_linkedin    - LinkedIn

markup:
&lt;a class="link social-ico__ico {$modifiers}" href="#" title="Icon title"&gt;&lt;/a&gt;

Styleguide 1.5.1
*/</span>

<span class="hljs-class">.social-ico__ico</span>
<span class="hljs-rules">{
<span class="hljs-rule"><span class="hljs-attribute">...
</span></span></span></code></pre>
<p><a href="https://github.com/varya/varya.github.com/blob/af38b1fb0bd6e5a1b043d002ad5dbf107f17e6c1/desktop.blocks/social-ico/social-ico.css#L49">github/varya/varya.github.com/desktop-blocks/social-ico/social-ico.css</a></p>
<p>В документации компоненты прорисованны по отдельности для каждого модификатора:
<a href="http://varya.me/styleguide/#/section/1.5.1">varya.me/styleguide/#/section/1.5.1</a></p>
<p>Для сложносоставных компоненты, которые используют внутри себя другие, я использовала ключевой тег <code>&lt;sg-insert&gt;</code>.
Он вставляет вместо себя код компонента с соответствующим номером.</p>
<pre class="highlight"><code class="hljs css"><span class="hljs-comment">/*
Sidebar
markup:
&lt;nav class="sidebar"&gt;
  &lt;sg-insert&gt;4.2&lt;/sg-insert&gt;
  &lt;sg-insert&gt;4.3&lt;/sg-insert&gt;
&lt;/nav&gt;
Styleguide 4.1
*/</span>

<span class="hljs-class">.sidebar</span>
<span class="hljs-rules">{
<span class="hljs-rule"><span class="hljs-attribute">...
</span></span></span></code></pre>
<p><a href="https://github.com/varya/varya.github.com/blob/af38b1fb0bd6e5a1b043d002ad5dbf107f17e6c1/desktop.blocks/sidebar/sidebar.css">github/varya/varya.github.com/desktop-blocks/sidebar/sidebar.css</a></p>
<p>Благодаря этому документация в коде приемлемого размера, а на сайте все раскрывается в полном виде:
<a href="http://varya.me/styleguide/#/section/4.1">varya.me/styleguide/#/section/4.1</a></p>
<h2 id="style-guide-driven-development">Style-Guide-Driven Development</h2>
<p>Если в получившемся стайл гайде в поле для поиска вы наберете &quot;logo&quot;, то увидите все компоненты, который используют
логотип! Поиск проводится по всему коду. Точно так же можно поискать компоненты, в разметке которых используется <code>&lt;em&gt;</code>.
Или в чьих стилях есть <code>font:</code>.</p>
<p>Мне лично особенно нравится, что можно искать и по разметке. Этим можно пользоваться во время рефакторинга. Например,
изменив input, я могу найти все использующие его блоки и посмотреть, не сломались ли они.</p>
<p>Хотя на самом деле это лишь небольшое дополнение к главному преимуществу использования стайл гайда. По-моему, его
основной плюс — <strong>демонстрация ошибок вёрстки</strong>.</p>
<p>В CSS моего блога ещё до внедрения стайл гайда использовался компонентый подход. Учитывая мой БЭМ опыт, я была на 100%
уверена, что компоненты написаны хорошо. Но даже такая компонентная разработка всё равно происходила с точки зрения
страницы. До того как блоки были внедрены в блог, я делала их на отдельной статической странице. То есть отдельно, вне
страницы, они никогда и не существовали.</p>
<p>Блоки разрабатывались как независимые, я писала код, пытаясь этого достигнуть. Но <strong>будучи размещенными вместе на одной и
той же странице, они никогда независимыми не были</strong>.</p>
<p>После того как SC5 Style Guide волшебным образом отрисовал их по отдельности, я могу видеть, что блок
<a href="http://varya.me/styleguide/#/section/1.1">logo</a> выровнен по правому краю. Хотя почему бы это? Очевидно, это моя ошибка,
допущенная, когда я верстала логитип внутри блока Header.</p>
<p>То же самое произошло с <a href="http://varya.me/styleguide/#/section/1.4">переключалкой языков</a>, она так же выровнена вправо.</p>
<p>В <a href="http://varya.me/styleguide/#/section/1.5">блоке социальных иконок</a> переключалка языков подразумевалась рядом с
иконкой RSS. Но на странице они располагаются близко друг к другу только потому что весь блок помещен в узкий контейнер.
В стайл гайде блок отрисован отдельно, и мне теперь видно, что он свёрстан неидеально.</p>
<p>Конечно, такие открытия подразумевают скорый рефакторинг :-)</p>
<p>И в довершение нужно сказать, что эксперимент не закончен. Есть и другие открытия для новых постов.</p>
]]></description>
            <link>http://varya.me//ru/posts/sc5-styleguide-for-smallers</link>
            <guid isPermaLink="true">http://varya.me//ru/posts/sc5-styleguide-for-smallers</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Tue, 18 Aug 2015 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Использование JSCS]]></title>
            <description><![CDATA[<p>Хочу поделиться опытом поддержания единого стиля JavaScript в одном из своих проектов. Недавно мы решили пробовать
молодой инструмент JSCS, и результат его использования понравился всем членам команды.</p>
<excerpt/>

<p>Когда я присоединилась к проекту <a href="http://styleguide.sc5.io/">SC5 Styleguide</a>, мне сразу бросилось в глаза отсутствие
единого стиля для JavaScript кода. Это ещё не было ужасающим, но было ясно, что проект в скором времени будет расти и чем раньше мы начнём
прилагать усилия к соблюдению единого стиля, тем лучше. Тем более, я уже знала о существовании и особенностях JSCS,
потому что на одном из моих проектов <a href="http://frontendbabel.info/articles/jscs-javascript-code-style/">публиковался перевод
статьи о нем</a>. Поэтому мы даже не стояли перед вопросом,
какой инструмент выбрать.</p>
<p>Конечно, есть и другие решения. Чаще всего называют JSLint и JSHint. Но давайте я сначала расскажу вам одну историю.</p>
<p>Оказывается, когда авторы JSHint познакомились с JSCS, он им так понравился, что они предпочли стать его
контрибьютерами, чем развивать проверку стиля в своём инструменте. А у себя оставили более сложные штуки, не про стиль,
а про программирование.</p>
<p><blockquote class="twitter-tweet" lang="ru"><p>And with that, JSCS now has all the style enforcement rules that are
being dropped in <a href="https://twitter.com/JSHint">@JSHint</a> 3.0: <a href="a
href=&quot;https://t.co/W98EMSiTN5&quot;">a
href=&quot;https://t.co/W98EMSiTN5&quot;</a><a href="https://t.co/W98EMSiTN5">https://t.co/W98EMSiTN5</a></a> cc <a href="a
href=&quot;https://twitter.com/valueof&quot;">a
href=&quot;https://twitter.com/valueof&quot;</a>@valueof</a></p>&mdash; Mike Sherov (@mikesherov) <a href="a
href=&quot;https://twitter.com/mikesherov/status/419596672520318976&quot;">a
href=&quot;https://twitter.com/mikesherov/status/419596672520318976&quot;</a>4 января 2014</a></blockquote></p>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>Получается, выбор стоит не между JSLint, JSHint и JSCS, а между JSLint и комбинацией JSHint + JSCS.</p>
<pre class="highlight"><code class="hljs javascript">gulp.task(<span class="hljs-string">'jslint'</span>,
  [ <span class="hljs-string">'jshint'</span>, <span class="hljs-string">'jscs'</span> ]
  );
</code></pre>
<p>А учитывая, что инструмент новый, со стройной архитектурой, контрибьютить в него будет одно удовольствие да и меньше
шансов на слишком долгую жизнь багов из-за какого-нибудь непроходимого легаси.</p>
<p>Вдохновляет также и тот факт, что JSCS уже выбрали такие уважаемые команды как разработчики jQuery, Bootsrap и
AngularJS.</p>
<p>Итак, JSCS — это npm-пакет, и установить его можно как глобально на свою машину так и локально на конкретный проект:</p>
<pre class="highlight"><code class="hljs cmake">npm <span class="hljs-keyword">install</span> jscs
</code></pre><p>Кроме того, понадобится создать конфигурационный файл <code>.jscsrc</code> и там описать, какого стиля должен придерживаться
JavaScript на вашем проекте. Этот файл помещается в корень проекта.</p>
<p>Несмотря на большое количество правил, которые поддерживает JSCS, конфиг вряд ли будет большим, потому что в инструменте
предусмотрены пресеты. Популярных стилей для JavaScript кода не так много, и если вы выбрали один из них, то нет нужды
описывать стиль полностью. Достаточно указать, на кого вы хотели бы быть похожим:</p>
<ul>
<li>airbnb</li>
<li>crockford</li>
<li>google</li>
<li>jquery</li>
<li>mdcs</li>
<li>wikimedia</li>
<li>yandex</li>
</ul>
<p>Даже если у вас есть расхождения с этими стилями, всё равно удобно выбрать максимально похожий пресет, потому что в JSCS
возможно переопределить правила пресета.</p>
<p>И, конечно, важно, что инструмент уже достаточно зрелый. А значит, есть все необходимые дружественные пакеты и плагины
для разных редакторов.</p>
<h2 id="-">Как это было</h2>
<p>В общем, учитывая все эти факты, мы остановились на JSCS. Начали с того, что написали подходящую нам конфигурацию и тут
же исключили из списка для проверки все наши файлы. У проекта уже была модульная структура, поэтому это оказалось
несложным.</p>
<pre class="highlight"><code class="hljs r">{
    <span class="hljs-keyword">...</span>

    <span class="hljs-string">"excludeFiles"</span>: [
      <span class="hljs-string">"node_modules/**"</span>,
      <span class="hljs-string">"src/modules/a/**"</span>,
      <span class="hljs-string">"src/modules/b/**"</span>,
      <span class="hljs-string">"src/*.js
    ]
}
</span></code></pre><p>Мы договорились, что начиная работать с каким-нибудь модулем, кроме реализации фич, мы также будем править стиль и
вычеркивать исправленные модули из списка непроверяемых файлов. Соблюдая это, мы довольно быстро исправили все файлы и
обошлись без конфликтов.</p>
<p>Гораздо важнее оказалось поддержание исправленных файлов в их исправленном состоянии во время будуших правок. Конечно,
тут нам помогают автоматические проверки. Но возникает вопрос, настолько строги мы должны быть в этих проверках и когда
именно проверять. Ведь поддержка стиля не должна становиться самоцелью и должна перетягивать на себя весь фокус
разработки.</p>
<p>В итоге мы пришли к концепции раздения ответственности. Так, для основного репозитория мы выбрали жесткую политику
в вопросе соблюдения стиля, а для форков — рекомендательную. Мы настроили Travis так, чтобы он проверял стиль для
пул-реквестов. Если стиль не соблюден, пул-реквест не может быть влит в основной репозиторий. Таким образом, там вообще
никогда нет кода с плохим стилем. В то же время для форков всё гораздо мягче. Мы отказались от насильственных pre-push
хуков с проверкой стиля, но рекомендуем самостоятельную установку pre-commit хука и использование плагинов JSCS для
редакторов, чтобы узнавать об ошибках в процессе разработки, а не тогда, когда ломается пул-реквест. Все рекомендации
написаны у нас в разработческой документации, и новые члены команды активно ими пользуются.</p>
<p>Всем особенно нравится, как реализована поддержка в редакторах. Ведь конфигурация стиля приезжает в репозиторий проекта
вместе с кодом, и редактор считывает её самостоятельно. А, главное, у разных проектов может быть разный стиль, и для
перекрестной работы не требуется никакая перенастройка.</p>
<p><img src="http://varya.me/jscs-talk/pictures/sublime.gif" alt=""></p>
<p>Ну и, конечно, всегда есть возможность запустить проверку стиля вручную как gulp-таск.</p>
<p><img src="http://varya.me/jscs-talk/pictures/travis.png" alt=""></p>
<h2 id="-">Предостережения</h2>
<p>Во время внедрения инструмента мы столкнулись с парочкой неудобств. Думаю, стоит о них упомянуть, тем более, что к ним
нашлись решения.</p>
<p>Основное расстройство — ошибка &quot;out of memory&quot; при запуске gulp-таска с проверкой. Оказалось, что недостаточно исключить
файлы в конфигурации JSCS. Gulp всё равно сначала пытается работать с ними всеми и пока дело доходит до JSCS, память уже
кончается. В итоге мы пришли к использованию пакета <code>gulp-ignore</code>:</p>
<pre class="highlight"><code class="hljs actionscript">gulp.task(<span class="hljs-string">'jscs'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> gulp.src([
    <span class="hljs-string">'**/*.js'</span>
  ])
  .pipe(gulpIgnore.exclude([
    <span class="hljs-string">'node_modules/**'</span>,
    <span class="hljs-string">'demo-output/**'</span>
  ]))
  .pipe(jscs());
})
</code></pre><p>Это не очень хорошее решение, ведь здесь пришлось перечислить все те исключения, которые уже задекларированы в <code>.jscsrc</code>.
Но лучшего варианта у нас пока нет.</p>
<p>И, второй момент: если вы используете watch в разработке, то скорее всего захотите видеть ошибки в терминале, но не
прерывать исполнение таска. Для этого потребуется <code>gulp-plumber</code>:</p>
<pre class="highlight"><code class="hljs r">gulp.task(<span class="hljs-string">'jscs'</span>, <span class="hljs-keyword">function</span>() {
  <span class="hljs-keyword">return</span> gulp.src([
    <span class="hljs-string">'**/*.js'</span>
  ])
  <span class="hljs-keyword">...</span>
  .pipe(plumber())
  .pipe(jscs());
});
</code></pre><p>Всё, больше никаких проблем или вопросов относительно иструмента у нас не было. Он прекрасно работает и уже сохранил нам
тысячи человекочасов.</p>
<h2 id="-">А также</h2>
<p>Возможно, вас также заинтересует <a href="http://habrahabr.ru/post/220229/">рассказ автора JSCS</a> и мои
<a href="http://varya.me/jscs-talk/">слайды</a> от доклада на эту тему.</p>
]]></description>
            <link>http://varya.me//ru/posts/jscs-in-use</link>
            <guid isPermaLink="true">http://varya.me//ru/posts/jscs-in-use</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Tue, 25 Nov 2014 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Запускать вовремя (о приложениях на Mac)]]></title>
            <description><![CDATA[<p>Я использую один и тот же ноутбук и для работы, и для личных дел. Это удобно, но за соблюдением баланса «работа-жизнь»
приходится следить дополнительно. Я поступаю просто: уходя с работы, закрываю все приложения. Главное не забывать их
открывать следующим утром. Но этот процесс можно автоматизировать :-)</p>
<p><excerpt/>
Особенно важно держать открытыми приложения, от которых зависит работа других членов команды. Например, с началом
рабочего дня должен быть запущен джаббер (или другой используемый мессенджер).</p>
<p>В AppGyver для общения всех со всеми
используют <a href="https://www.flowdock.com">Flowdock</a>. Вот мне и понадобилось гарантированно иметь его открытым с утра.</p>
<p>Оказалось, что на Mac запуск приложения в определенное время можно сделать штатными средствами — при помощи приложения
Calendar. Вот как:</p>
<p>###Создайте в Календаре новое событие</p>
<p>Я назвала своё «Run Flowdock». Время события не обязательно устанавливать с учетом того, чтобы компьютер был уже открыт.
Можно и удобно запускать всё заранее. У моего события стоит <code>9:35</code>.</p>
<h3 id="-">Сделайте событие повторяющимся</h3>
<p>Событие должно повторяться каждую неделю по рабочим дням.</p>
<h3 id="-">Запускайте приложение</h3>
<p>А теперь самое интересное. Приложение можно запускать как кастомное уведомление о событии.<br/><br/>
В выпадушке <code>alert</code> нужно выбрать самый последний пункт — <code>Custom</code>.<br/>
<img
class="article__image"
src="http://img-fotki.yandex.ru/get/4802/14441195.32/0_88921_7d53950e_L.png" width="300" height="500" border="0"
title="" alt=""/></p>
<p>В появившемся диалоге вместо <code>Message</code> нужно выбрать <code>Open file</code></p>
<p><img
class="article__image"
src="http://img-fotki.yandex.ru/get/4813/14441195.32/0_88925_47986a79_M.png" width="300" height="167" border="0"
title="" alt=""/>
<img
class="article__image"
src="http://img-fotki.yandex.ru/get/5109/14441195.32/0_88924_ea39983e_M.png" width="300" height="162" border="0"
title="" alt=""/></p>
<p>Под файлом здесь понимается приложение. По умолчанию это <code>Calendar</code>, но можно выбрать и другое.</p>
<p><img
class="article__image"
src="http://img-fotki.yandex.ru/get/4810/14441195.32/0_88922_22d155c7_M.png" width="300" height="193" border="0"
title="" alt=""/></p>
<p>Затем в диалоговом окне Finder выбрать нужное приложение из папки <code>Applications</code>. В моём случае это Flowdock.</p>
<p><img
class="article__image"
src="http://img-fotki.yandex.ru/get/4809/14441195.32/0_88923_7597bf28_M.png" width="300" height="196" border="0"
title="" alt=""/></p>
<p>Затем корректируем время. За 5 минут до 9:35 — как раз будет полдесятого. Напоминаю, это вовсе не означает, что к этому
времени нужно сидеть на работе с открытым ноутбуком. Можно ехать в автобусе или вообще спать. Приложение запустится
тогда, когда вы откроете крышку.</p>
<h3 id="-">Минусы</h3>
<p>Не без минусов. Этот же календарь на iPhone в 9:30 пиликает уведомлением о событии. Файл на телефоне он открыть не
может, поэтому просто радостно сообщает, что вот оно событие наступает.</p>
]]></description>
            <link>http://varya.me//ru/posts/run-app-in-time-on-mac</link>
            <guid isPermaLink="true">http://varya.me//ru/posts/run-app-in-time-on-mac</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Wed, 10 Sep 2014 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Про дружбу народов во frontend сообществе]]></title>
            <description><![CDATA[<p>Когда-то я читала о web-разработке только на русском. Позднее, выучившись на курсах английского, я стала всё больше и
больше читать англоязычные блоги и статьи. Также было и с конференциями: начав с русскоязычных, я затем стала посещать и
зарубежные. Иногда и со статьями, и с
докладами, я замечала, что контент очень разный. Бывало, складывалось впечатление, что каждое сообщество безусловно
развивается, но своим путём.</p>
<p><excerpt/>
Думаю, многие русскоязычные разработчики знают статью Виталия Харисова «<a href="http://vitaly.harisov.name/article/independent-blocks.html">Вёрстка независимыми
блоками</a>».
Виталий опубликовал её в 2008 году, обозначив основные принципы вёрстки, известные сейчас под именем БЭМ. Можно считать,
что с того момента началось развитие БЭМ в России и соседних странах. А разработчики, владеющие английским языком,
узнали про БЭМ лишь в 2012 году из <a href="http://www.smashingmagazine.com/2012/04/16/a-new-front-end-methodology-bem/">моей статьи в
SmashingMagazine</a>.
Потом, как вы знаете, методология понравилась <a href="http://csswizardry.com/about/">Гари Робертсу</a> и благодаря его публикациям распространилась и на Западе.</p>
<p>Итак, прошло <strong>4 года</strong> между тем как технология была выпущена в свет и тем как о ней узнал обычный фронтендер из Алабамы.
За такой срок многие технологические вещи даже успевают устареть.</p>
<p>Нет никаких сомнений: и для технологии, и для индустрии было бы намного лучше, узнай массовый пользователь о БЭМ в
далеком 2008. Скорее всего развитие модульных технологий в Web началось бы раньше, и пошло бы быстрее. Уже сейчас мы бы
использовали WebComponents (реализующие идеи компонентного подхода БЭМ) повсеместно.</p>
<p>Некоторое время назад, размышляя над фактами, изложенными выше, я решила посвящать часть своего времени и страниц в блоге
переводам. Так появились посты-переводы про <a href="/en/issues/ym-modular-system">Ymaps modules</a> и
<a href="/en/issues/beml-html-preprocessor">BEML</a>. Сразу скажу, на очереди для перевода были и другие статьи. Читая личные блоги и
Хабр, я видела, что люди пишут уйму всего интересного. Но... разве только в России?</p>
<p>Представьте, сколько новых решений, библиотек, фреймворков есть на сегодняшний момент в других уголках света!
Только вы о них не узнаете, ведь их авторы говорят на арабском, испанском, японском и на многих других неизвестных вам
языках :-)</p>
<p>И всё-таки мы живём в удивительное время, и у нас, разработчиков интерфейсов, потрясающее сообщество. Open source
культура и такие технологии как GitHub позволяют нам помогать друг другу и добиваться намного больших результатов
вместе. При этом вовсе не обязательно коммитить в NodeJS, чтобы внести свой вклад. Так, например, работает известный многим
проект <a href="http://frontender.info/">Frontender.info</a> — благодаря коллективному труду у русскоязычных разработчиков есть постоянно обновляемый ресурс с
переводами самых актуальных статей с английского языка на русский.</p>
<p>Всё это подтолкнуло меня к созданию сервиса коллективных переводов на английский.</p>
<p>Проект называется <strong>Frontend Babel </strong> и уже доступен по адресу <a href="http://frontendbabel.info">http://frontendbabel.info</a>.
Это статический блог (здесь я говорю спасибо DocPad за генерацию) — любой может развернуть его у себя, добавить
статью-перевод и пул-реквестом влить в сайт.</p>
<ul>
<li><a href="http://frontendbabel.info/about/">о проекте</a></li>
<li><a href="https://github.com/frontendbabel/frontendbabel.github.com">репозиторий</a></li>
<li><a href="http://frontendbabel.info/how-to-contribute">как контрибьютить</a></li>
</ul>
<p>Первые статьи уже перевёл с русского <a href="https://www.google.com/+MaxShirshin">Макс Ширшин</a>. Это</p>
<ul>
<li>интересная <a href="http://frontendbabel.info/articles/webpage-rendering-101">заметка Александра Скутина о рендеринге
страниц</a> (вы могли читать её на Хабре)</li>
<li>и прекрасная <a href="http://frontendbabel.info/articles/graphical-interface">статья Данила
Ковчего о графическом интерфейсе</a>.</li>
</ul>
<p>Можете уже сейчас поделиться этими
ссылками со своими англоязычными коллегами :-) Пусть узнают, какой у нас создаётся хороший контент.</p>
<p>Мы с Максом собираемся переводить всё новые и новые статьи. Также я приглашаю присоединиться к проекту арабо- японо-
испано- (тут даже бессмысленно перечислять каких ещё) язычных разработчиков. Надеюсь, они откликнутся, и мы наконец-то сможем узнать об
идеях и технических новинках наших коллег. Правда, вдохновить их на работу можно будет только собственным примером. Так
что, присоединяйтесь и вы.</p>
<p>Конечно, переводить на чужой язык намного сложнее, чем на родной. Но всё равно я хочу вас воодушевить. Все статьи
будут вычитываться (пока нами с Максом, а очень скоро — нейтивами), если вы ещё не пишете на английском, но хотели
начать, это отличная возможность потренироваться и научиться новому.<br/>
Статьи с хорошим контентом получают траффик. И упоминание автора и переводчика статьи (со ссылками на сайт и
социальные сети) — это заслуженные ими упоминание и новые профессиональные контакты.</p>
<p>Всегда помните: вклад в open source проект может быть небольшим, но в любом случае он неоценим! Вот лишь несколько идей,
каким может быть ваше участие:</p>
<ul>
<li><a href="https://github.com/frontendbabel/frontendbabel.github.com/issues/new">Добавьте статью в очередь на
перевод</a><br/>
Если вы знаете интересную статью (да хоть вашу собственную), которую стоит опубликовать, заведите issue об этом. Другой
участник проекта увидит эту задачу и переведёт.</li>
<li><a href="http://frontendbabel.info/how-to-contribute#push-new-translation">Сделайте свой перевод</a><br/>
Найдите интересную статью на русском, переведите её на английский и опубликуйте на сайте.</li>
<li><strong>Расскажите друзьям и коллегам о проекте</strong><br/>
Написав о Frontend Babel в Twitter, Facebook или своём блоге, вы поможете привлечь новых участников проекта. Особенно
круто вставить несколько мотивационных слов от себя :-)</li>
<li>Поправьте английский в статьях<br/>
Если вы видите грамматическую ошибку или опечатку, статью можно отредактировать (внизу, под текстом, есть ссылка) и
предложить свой pull request.</li>
<li>Предложите улучшения на сайте<br/>
Посоветуйте, что можно было бы улучшить, изложив свои идеи в
<a href="https://github.com/frontendbabel/frontendbabel.github.com/issues?labels=%40+Translation&amp;state=open">списке
задач</a>.</li>
<li><a href="https://github.com/frontendbabel/frontendbabel.github.com/issues?labels=&amp;page=1&amp;state=open">Возьмите на себя задачу</a><br/>
С вашим участием сайт может стать намного лучше!</li>
</ul>
]]></description>
            <link>http://varya.me//ru/posts/frontend-babel-alpha</link>
            <guid isPermaLink="true">http://varya.me//ru/posts/frontend-babel-alpha</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Mon, 30 Jun 2014 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Первая неделя Frontend Babel]]></title>
            <description><![CDATA[<p>В прошлый понедельник запустился новый проект коллективных переводов фронтендерских статей на английский <a href="http://frontendbabel.info/">Frontend
Babel</a>. Я писала об этом <a href="/ru/posts/frontend-babel-alpha">подробный пост</a>, который очень
хорошо разошелся благодаря ретвитам и попаданию на Хабр. И насколько я могу судить по статистике, неделя прошла
отлично.</p>
<excerpt/>

<p>Первый перевод проекта — статья «<a href="http://frontendbabel.info/articles/webpage-rendering-101/">What Every Frontend Developer Should Know About Webpage
Rendering</a>» попала в популярные рассылки <a href="http://css-weekly.com/">CSS
Weekly</a> и <a href="http://html5weekly.com/">HTML5 Weekly</a>. Благодаря им уже на следующий день сайт
посетило больше 9 тысяч человек! А всего за неделю было 35 тысяч просмотров.</p>
<p>А вот картинка про то, какую аудиторию получили публикации, которые могли рассчитывать только на русскоязычных читателей
всего две недели тому назад:</p>
<p><img src="http://img-fotki.yandex.ru/get/6745/14441195.32/0_85670_478637f6_orig.png" alt=""></p>
<p>Более того, спустя ещё день devrel Google Chrome Пол Льюис (<a href="https://twitter.com/aerotwist">@aerotwist</a>) опубликовал
в своём блоге пост с дополнительной информацией, о том как именно браузер рисует страницу — «<a href="http://aerotwist.com/blog/pixels-are-expensive/">Pixels are
expensive</a>». Упоминание Полом Frontend Babel стало ещё одним источником трафика — более
полутора тысяч посетителей. Но главное даже не это, а то что благодаря Frontend Babel <strong>состоялся диалог</strong>. Языковые
границы стираются, и развитие нашей индустрии ускоряется. Очень круто видеть такой результат уже в первую неделю работы!</p>
<p>Если вы уже вдохновлены стать причастными к этому успеху, <a href="https://github.com/frontendbabel/frontendbabel.github.com/issues?labels=%24+Russian&amp;page=1&amp;state=open">берите и
переводите</a> :-)
Кстати, не бойтесь сделать ошибку. Frontend Babel — это ресурс для англоязычной аудитории, и среди читателей обязательно
найдётся кто-то, кто исправит вас Pull-Request&#39;ом. Это тоже <a href="https://github.com/frontendbabel/frontendbabel.github.com/pull/42">подтверждено
опытом</a>, даже <a href="https://github.com/frontendbabel/frontendbabel.github.com/pull/74">несколько
раз</a>.</p>
<p>Или можно <a href="https://github.com/frontendbabel/frontendbabel.github.com/issues/new">добавить статью в пул на перевод</a>. Там
уже есть сколько-то, но много не мало.</p>
<p>Ближайшее время (за вычетом переводов) я планирую посвятить расширению языковой географии Frontend Babel. Уже сейчас в
очереди есть статьи <a href="https://github.com/frontendbabel/frontendbabel.github.com/issues?labels=%24+French&amp;page=1&amp;state=open">на
французском</a> и
<a href="https://github.com/frontendbabel/frontendbabel.github.com/issues?labels=%24+Polish&amp;page=1&amp;state=open">польском</a>. Дело
за малым — надо найти переводчиков :-)</p>
<h2 id="changelog">Changelog</h2>
<p>Сам сайт Frontend Babel претерпел изменения и внешнего вида, и сборки. Здесь спасибо <a href="http://kizu.ru/">Роме Комарову</a>, он
насоздавал кучу issue, и их реализация делает сайт намного лучше с точки зрения UX.</p>
<p>Изменения же генерации сайта понадобились, чтобы у статей появились мета-описание и кратинка. Это делает их более
привлекательными, когда делишься ссылкой в Facebook или LinkedIn. Сниппет третьей статьи «<a href="http://frontendbabel.info/articles/developing-cross-browser-extensions/">Developing Cross-Browser
Extensions</a>» уже выглядел вот так:</p>
<p><img src="http://img-fotki.yandex.ru/get/6843/14441195.32/0_8566f_734ee93c_orig.png" alt=""></p>
<p>Хорошо бы ещё иметь такую картинку для корня проекта. Кто-нибудь может нарисовать? Ну и если у вас есть другие идеи по
улучшению, не стесняйтесь <a href="https://github.com/frontendbabel/frontendbabel.github.com/issues/new">завести issue</a>.</p>
]]></description>
            <link>http://varya.me//ru/posts/frontend-babel-first-week</link>
            <guid isPermaLink="true">http://varya.me//ru/posts/frontend-babel-first-week</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Mon, 02 Jun 2014 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Мобильное приложение на Steroids]]></title>
            <description><![CDATA[<p>На днях я написала своё первое мобильное приложение. Суммарно это заняло всего
пару часов, и всё благодаря фреймворку
<a href="http://www.appgyver.com/steroids">Steroids</a> от AppGyver. С его помощью делать
гибридные приложения (это когда HTML5/JavaScript внутри) очень легко, а
инструменты <code>Steroids</code> позволяют легко деплоить приложение и делиться им с
друзьями.<excerpt/></p>
<h3 id="-">Легко посмотреть приложение</h3>
<p>Приложение у меня пока &quot;игрушечное&quot; — это всего одна страница, где озвучены
случайные числительные на финском языке.</p>
<div style="text-align:center;">
<img
src="http://img-fotki.yandex.ru/get/9827/14441195.30/0_81ae7_60ff43b1_L.png"
width="282" height="500" title="" alt="" border="0"/>
</div>

<p>Сейчас увидеть работающее приложение в телефоне можно только через <code>Appgyver
Scaner</code> — вспомогательную программу для обмена Steroids-based мобильными
приложениями до релиза. Поставьте сейчас, чтобы позже загрузить моё приложение:</p>
<div style="text-align:center;">
<a href="https://itunes.apple.com/us/app/appgyver-scanner/id575076515?mt=8"
target="_blank"><img alt="Appstore" class="appstore_icon"
src="https://share.appgyver.com/assets/appstore-df950585b54bd081a7826913fc715cd4.png"></a>
<a href="https://play.google.com/store/apps/details?id=com.appgyver.android&amp;feature=nav_result#?t=W251bGwsMSwxLDMsImNvbS5hcHBneXZlci5hbmRyb2lkIl0."
target="_blank"><img alt="Googleplay" class="appstore_icon"
src="https://share.appgyver.com/assets/googleplay-2cef882d62e402fbdbfe8cdac5794069.png"></a>
</div>

<p>Теперь вы можете открыть в компьютере эту
<a href="http://bit.ly/finnish-counting-001">страницу с QR-кодом</a>. Отсканируйте QR-код
при помощи
свежеустановленного AppGyver Scaner, и моё приложение загрузится к вам в
телефон.</p>
<p>Я сознательно не релизила пока приложение. Во-первых, оно ещё сырое. А
во-вторых, хочу, чтобы вы увидели как легко поделиться готовящимся
приложением с другими, причем на любом этапе разработки.</p>
<h3 id="-dev-">Запустить dev-версию</h3>
<p>Код приложения открытый, хостится на Github:
<a href="https://github.com/varya/finnish-counting">varya/finnish-counting</a>. Чтобы
развернуть проект у себя на машине, понадобится npm-пакет <code>steroids</code>:</p>
<pre class="highlight"><code class="hljs cmake">npm <span class="hljs-keyword">install</span> steroids -g
</code></pre><p>Если до этого npm-пакеты на машину не устанавливались, то придется пройти через
все шаги <a href="http://academy.appgyver.com/categories/1/contents/1">инструкции по
установке</a>.</p>
<p>Затем нужно склонировать код проекта и установить зависимости:</p>
<pre class="highlight"><code class="hljs less"><span class="hljs-attribute">git</span> clone git<span class="hljs-variable">@github</span>.<span class="hljs-attribute">com</span>:varya/finnish-counting.git -b develop
cd finnish-counting
npm install
</code></pre><p>Для начала работы с проектом запускаем</p>
<pre class="highlight"><code class="hljs applescript">steroids connect <span class="hljs-comment">--watch</span>
</code></pre><p>Ключ <code>--watch</code> нужен для отслеживания изменений и перезагрузки приложения.</p>
<p>После запуска этой команды в браузере откроется страница с QR-кодом.
Отсканировав QR-код всё тем же AppGyver Scaner, вы получите приложение прямо в
телефоне. Только имейте в виду, что телефон и компьютер должны находиться в
одной сети. При каждой редакции кода приложение будет обновляться – очень
удобно, особенно если работаешь над внешним видом интерфейса.</p>
<p>Если телефона под рукой нет, можно открыть приложение на макет в iOS simulator.
Для этого в терминале с запущенным <code>steroids</code> нужно просто написать</p>
<pre class="highlight"><code class="hljs nginx"><span class="hljs-title">simulator</span>
</code></pre><h3 id="-">Что писать?</h3>
<p>Основной код приложения находится в
<a href="https://github.com/varya/finnish-counting/blob/vesions/0.0.1/www/javascripts/application.js">www/application.js</a>.
Оно ещё маленькое и не использует все возможности Steroids. Но уже очевидно, что
когда страниц станет больше, мне понадобится <a href="http://docs.appgyver.com/en/edge/steroids_Steroids%20Native%20UI_index.md.html#Steroids%C2%A0Native%C2%A0UI">Steroids Native
UI</a>.</p>
<p>Другие возможности фреймворка такие как удобное обращение к камере, файловой
системе телефона, нотификациям — хорошо задокументированы на страницах <a href="http://docs.appgyver.com/en/edge/index.html">API
Docs</a>. Там же есть примеры
использования <code>Cordova API</code> — именно с его помощью в моём приложении
проигрывается звук.</p>
<p>Новые приложения появляются каждый день, можно релизить и хвастаться в <a href="http://x.appgyver.com/xapps">AppGyver
Apps Gallery</a>. Только успевай с идеями: я вот
хотела написать мобильный аналог игры 2048, а он уже там есть. Значит, буду
развивать свою «считалку» :-)</p>
<p>Кстати, у кого есть телефон на Андроиде — проверьте, скачивается у вас моё
приложение, работает ли? Я пока могу проверить только на iOS, а одно из
преимуществ приложений на Steroids — то, что они кросс-платформенные, с
нативными фичами для каждой платформы, конечно.</p>
]]></description>
            <link>http://varya.me//ru/issues/first-steroids-app</link>
            <guid isPermaLink="true">http://varya.me//ru/issues/first-steroids-app</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Wed, 02 Apr 2014 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Локальная разработка и удаленный хостинг статики]]></title>
            <description><![CDATA[<p>На прошлой неделе мне понадобилось сделать сайт, статика которого раздаётся с
другого сервера. Это касалось всех статических файлов: как подключенных к HTML
документу CSS и JavaScript, так и изображений и шрифтов, использованных уже в
их коде.<excerpt/> Хотя очевидно, что все они эти ресурсы должны быть локальными во
время разработки. То есть задача была придумать магию, которая знает, где будет
размещена статика, и преобразовывает относительные пути в коде в абсолютные
согласно этому знанию.</p>
<p>Эту задачу я решила при помощи инструмента
<a href="http://bem.info/tools/optimizers/borschik/">Borschik</a>. Борщик-сборщик, всем
должно быть понятно. :-)</p>
<center>
<iframe src="//embed.gettyimages.com/embed/135591409?et=B_T3l-shrE-pr9-ELe_wJw&sig=5haG67PAzCxGourA96ZB7m9LwSket1v9PpvXEXNIkBM=" width="508" height="407" frameborder="0" scrolling="no"></iframe>
</center>

<p>Демо-проект с этим решением находится в репозитории
<a href="https://github.com/varya/st-deliverer">varya/st-deliverer</a></p>
<h3 id="-">Структура проекта</h3>
<p>Как вы позже увидите, <code>borschik</code> можно гибко настроить. Так что возможна любая
структура проекта. В моём проекте все хранится в директории
<a href="b.com/varya/st-deliverer/tree/master/src">src</a>.
После сборки получается HTML-файлы в папке
<a href="https://github.com/varya/st-deliverer/tree/gh-pages/dist/html">dist/html</a>.
Проверьте его код, и вы убедитесь, что статические файлы подключены с другого
хоста по абсолютному пути.</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>Deliver static assets with Borschik<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">link</span>
      <span class="hljs-attribute">rel</span>=<span class="hljs-value">"stylesheet"</span>
      <span class="hljs-attribute">href</span>=<span class="hljs-value">"http://varya.github.io/stor.../styles.css"</span>/&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">body</span>
    <span class="hljs-attribute">class</span>=<span class="hljs-value">"page"</span>
    <span class="hljs-attribute">background</span>=<span class="hljs-value">"http://varya.github.io/stor.../grungy.jpg"</span>&gt;</span>
  ...
</code></pre>
<p>Страничку можно <a href="http://varya.me/st-deliverer/dist/html/">открыть в браузере</a> и
насладиться моим дизайном и прекрасным котиком.</p>
<h3 id="borschik-">Borschik в вашем проекте</h3>
<p>Borschik — это npm-пакет. Его можно установить глобально при помощи команды</p>
<pre class="highlight"><code class="hljs bash">npm install -g borschik
</code></pre>
<p>Но лично я предпочитаю локальные зависимости, так что завожу в корне проекта
файл
<a href="https://github.com/varya/st-deliverer/blob/master/package.json">package.json</a>:</p>
<pre class="highlight"><code class="hljs javascript">{
  ...
  <span class="hljs-string">"dependencies"</span>: {
    <span class="hljs-string">"borschik"</span>: <span class="hljs-string">"0.4.2"</span>
  },
  ...
}
</code></pre>
<h3 id="-">Настройка</h3>
<p>Прежде чем начинать преобразования, нужно проинструктировать <code>borschik</code>, что
преобразовывать и как. Для этого нужен конфигурационный файл
<a href="https://github.com/varya/st-deliverer/blob/master/.borschik">.borschik</a>:</p>
<pre class="highlight"><code class="hljs javascript">{
  <span class="hljs-string">"paths"</span> : {
    <span class="hljs-string">"src/img/"</span>: <span class="hljs-string">"http://varya.github.io/stor.../st-deliverer/img/"</span>,
    <span class="hljs-string">"src/css/"</span>: <span class="hljs-string">"http://varya.github.io/stor.../st-deliverer/css/"</span>,
    <span class="hljs-string">"src/font/"</span>: <span class="hljs-string">"http://varya.github.io/storage/fonts/"</span>

  }
}
</code></pre>
<p>Заметьте, для разных путей можно настроить разную замену. Здесь это видно на
примере с фонами.</p>
<h3 id="-">Запускаем!</h3>
<p>Запустите <code>borschik</code> над файлом, содержащим ссылки на локальные статические
ресурсы, и вы получите результат преобразования. Например,</p>
<pre class="highlight"><code class="hljs bash">./node_modules/borschik/bin/borschik \
  --input=src/css/styles.css
</code></pre>
<p>Чтобы использовать это в сборке, понадобится ещё один флаг <code>--output</code>,
сообщающий куда записать получившееся.</p>
<p><code>borschik</code> знаком с синтаксисом web-технологий. То есть &quot;ссылки&quot; размещенные в
простом тексте останутся нетронутыми.</p>
<h3 id="-">Система сборки</h3>
<p>Теперь <code>borschik</code> можно включить в систему сборки проекта. В моём случае это
небольшой
<a href="https://github.com/varya/st-deliverer/blob/master/Makefile">Makefile</a>, спасибо
<a href="https://github.com/alexeyten">@alexeyten</a> за 90% его содержания. :-) Но есть
также и плагин для grunt <a href="https://github.com/megatolya/grunt-borschik">megatolya/grunt-borschik</a>.<br/>
Конечно, <code>borschik</code> включен в системы сборки БЭМ-проектов
<a href="http://bem.info/tools/bem/bem-tools/">bem-tools</a>
и <a href="https://github.com/enb-make/enb">enb</a></p>
<h3 id="-">Результат</h3>
<p>Для закрепления <a href="http://varya.me/st-deliverer/dist/html/">проведайте котика ещё раз</a>.</p>
<p>А узнать о многих других возможностях <code>borschik</code> можно из статьи
<a href="http://ru.bem.info/articles/borschik/">http://ru.bem.info/articles/borschik/</a>.</p>
]]></description>
            <link>http://varya.me//ru/issues/borschik-static-assets</link>
            <guid isPermaLink="true">http://varya.me//ru/issues/borschik-static-assets</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Wed, 12 Mar 2014 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[JavaScript в BEMJSON]]></title>
            <description><![CDATA[<p>Обычно разработка страницы начинается с прототипирования интерфейса и затем
продолжается созданием статической странички при помощи HTML/CSS и элементарного
JavaScript. Если использууется полный стек БЭМ, переход от прототипирования к
полноценному сайту происходит постепенно. Можно склонировать проект
<a href="https://github.com/bem/project-stub">project-stub</a>
и сделать статическую страницу, об этом уже опубликован
<a href="http://bem.info/articles/start-with-project-stub/">туториал</a>.<excerpt/></p>
<p>Благодаря <code>BEMHTML</code> вам не нужно писать весь HTML для страницы вручную. Описывая
страницу в BEMJSON, вы экономите время, ведь не нужно писать каждый тег. Но в
случае больших страниц этого мало.</p>
<p>К счастью, в BEMJSON можно включать JavaScript, результатом которого будет
описание блоков.
Вот пример такой страницы:</p>
<pre class="highlight"><code class="hljs javascript">({
    block: <span class="hljs-string">'page'</span>,
    ...
    content:[
        ...
        {
            block: <span class="hljs-string">'content'</span>,
            content: (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">var</span> res = [];
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
                    res.push({
                        block: <span class="hljs-string">'button'</span>,
                        content: <span class="hljs-string">'Button '</span> + (i + <span class="hljs-number">1</span>)
                    });
                }
                <span class="hljs-keyword">return</span> res;
            })()
        },
        ...
    ]
})
</code></pre>
<p><a href="https://github.com/varya/dynamic-bemjson/blob/master/desktop.bundles/page1/page1.bemjson.js">полный
код</a></p>
<p>Когда страница собирается при помощи <code>bem-tools</code>, этот JavaScript создает 10
блоков <code>button</code>.
Можете проверить <a href="http://varya.me/dynamic-bemjson/desktop.bundles/page1/page1.html">результирующую страницу</a>
чтобы увидеть их.</p>
<p>Ещё одним примером может служить блок <code>menu</code>. Такой интерфейсный компонент
обычно состоит из множества повторяющихся пунктов с минимальными различиями.
Получается копипаст, которого можно избежать, используя JavaScript в BEMJSON.</p>
<pre class="highlight"><code class="hljs javascript">({
    block: <span class="hljs-string">'page'</span>,
    ...
    content:[
        ...
        {
            block: <span class="hljs-string">'menu'</span>,
            content: [
                {
                    title: <span class="hljs-string">'Index'</span>,
                    isSelected: <span class="hljs-literal">false</span>,
                },
                {
                    title: <span class="hljs-string">'Products'</span>,
                    isSelected: <span class="hljs-literal">true</span>
                },
                {
                    title: <span class="hljs-string">'Contact'</span>,
                    isSelected: <span class="hljs-literal">false</span>
                }
            ].map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span></span>{
                <span class="hljs-keyword">var</span> block = {
                    block: <span class="hljs-string">'menu'</span>,
                    elem: <span class="hljs-string">'item'</span>,
                    content: item.title,
                    mods: {
                        selected: item.isSelected
                    }
                };
                <span class="hljs-keyword">return</span> block;
            })
        },
        ...
    ]
})
</code></pre>
<p><a href="https://github.com/varya/dynamic-bemjson/blob/master/desktop.bundles/page2/page2.bemjson.js">full
code</a></p>
<p>В результате получается <a href="http://varya.me/dynamic-bemjson/desktop.bundles/page2/page2.html">страница с меню из 3х пунктов</a>.
Чем больше массив с пунктами меню, тем больше пользы. Особенно если структура
меню меняется в процессе разработки.</p>
<p>Конечно, этой возможностью не придется пользоваться, если BEMJSON — это
результат первого слоя шаблонов (таких как BEMTREE или priv.js) — там вы можете
произвести столько BEMJSON, сколько требуется. Но на первом этапе разработки,
когда делается статическая страница, трюки с JavaScript в BEMJSON помогут
избежат копипаста.</p>
]]></description>
            <link>http://varya.me//ru/issues/javascript-in-bemjson</link>
            <guid isPermaLink="true">http://varya.me//ru/issues/javascript-in-bemjson</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Tue, 21 Jan 2014 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Блоки как кирпичи и бандлы как дома]]></title>
            <description><![CDATA[<p>Некотрое время назад мой знакомый, который делает проект на полном стеке БЭМ
(BEM-CSS, i-bem.js и BEMHTML-шаблоны),
задал мне несколько вопросов об использовании
<a href="https://github.com/bem/project-stub/tree/14e24fd17ba66a357a2f6fcdce045065b4eb5d6c">BEM project
stub</a>.
Отвечая на вопрос, я пообещала опубликовать ответ в виде текста, потому что
многие вещи вокруг БЭМ не проговариваются, считаясь слишком простыми — и
ошибочно!<excerpt/></p>
<p>Вопрос был о конфигурационном файле <code>.bem/make.js</code>, который нужен при
использовании
<a href="http://bem.info/tools/bem/bem-tools/">bem tools</a>
для сборки страниц.
<a href="https://github.com/bem/project-stub/blob/14e24fd17ba66a357a2f6fcdce045065b4eb5d6c/.bem/make.js#L12">Строчки 12 и
13</a>
описывают регулярные выражения для <code>blocks</code> и <code>bundles</code>. Не сразу понятно,
что это значит.</p>
<p>Вообще эти выражения нужны, чтобы распознать папки на файловой системе. Те,
которые заканчиваются на <code>.blocks</code> — для блоков, а те, что заканчиваются на
<code>.bundles</code> — для бандлов (страниц). Под эти выражения, например, подходят папки
<code>desktop.blocks</code> и <code>desktop.bundles</code> из project-stub.</p>
<p>Для чего нужна папка <code>desktop.blocks</code>, должно быть понятно. Поскольку БЭМ —
модульный паттерн, необходимо место для хранения модулей, то есть блоков. Каждый
блок — это директория, содержащая все файлы, нужные для каждого конкретного
интерфейсного модуля.</p>
<p>Вот, например, <a href="https://github.com/varya/online-shop-dummy/tree/master/desktop.blocks">набор блоков одного
проекта</a>.</p>
<p>Папка <code>desktop.bundles</code> нуждается в пояснении. Она содержит страницы – результат
использования блоков. Каждая страница помещена в отдельную директорию, внутри
которой располагаются все файлы, нужные для страницы.
Можно снова посмотреть
<a href="https://github.com/varya/online-shop-dummy/tree/gh-pages/desktop.bundles">пример из предыдущего
проекта</a>.</p>
<p>Разница в том, что файлы блоков созданы разработчиком, а файлы бандлов созданы
bem tools. Для блоков это знакомые нам CSS, JavaScript и иногда шаблоны.</p>
<pre class="highlight"><code class="hljs stylus">├── desktop.blocks/
│   ├── goods/
│   │   ├── &lt;<span class="hljs-tag">a</span> href=<span class="hljs-string">"https://github.com/varya/online-shop-dummy/blob/master/desktop.blocks/goods/goods.bemhtml"</span>&gt;goods.bemhtml&lt;/a&gt;
│   │   ├── &lt;<span class="hljs-tag">a</span> href=<span class="hljs-string">"https://github.com/varya/online-shop-dummy/blob/master/desktop.blocks/goods/goods.css"</span>&gt;goods.css&lt;/a&gt;
│   │   ├── &lt;<span class="hljs-tag">a</span> href=<span class="hljs-string">"https://github.com/varya/online-shop-dummy/blob/master/desktop.blocks/goods/goods.deps.js"</span>&gt;goods<span class="hljs-class">.deps</span><span class="hljs-class">.js</span>&lt;/a&gt;
│   │   └── &lt;<span class="hljs-tag">a</span> href=<span class="hljs-string">"https://github.com/varya/online-shop-dummy/blob/master/desktop.blocks/goods/goods.ie.css"</span>&gt;goods<span class="hljs-class">.ie</span><span class="hljs-class">.css</span>&lt;/a&gt;</code></pre>

<p>Проводя параллели для БЭМ (и любого другого модульного паттерна) в реальном
мире, можно сказать, что блок — это кирпичик.</p>
<p><img src="http://img-fotki.yandex.ru/get/6730/14441195.30/0_7e0f8_33c1c86c_L.jpg" alt=""></p>
<p>Файлы бандлов — это тоже файлы, нужные для браузера: CSS, JavaScript, HTML. <em>Ни
один из них не написан разработчиком, они созданы bem tools</em>. Можете посмотреть
внутрь файлов и убедиться, что код абсолютно &quot;роботный&quot;.</p>
<pre class="highlight"><code class="hljs stylus">├── desktop.bundles/
│   ├── index/
│   │   ├── &lt;<span class="hljs-tag">a</span> href=<span class="hljs-string">"https://github.com/varya/online-shop-dummy/blob/gh-pages/desktop.bundles/index/_index.css"</span>&gt;_index.css&lt;/a&gt;
│   │   ├── &lt;<span class="hljs-tag">a</span> href=<span class="hljs-string">"https://github.com/varya/online-shop-dummy/blob/gh-pages/desktop.bundles/index/_index.js"</span>&gt;_index.js&lt;/a&gt;
│   │   ├── &lt;<span class="hljs-tag">a</span> href=<span class="hljs-string">"https://github.com/varya/online-shop-dummy/blob/gh-pages/desktop.bundles/index/index.bemjson.js"</span>&gt;index<span class="hljs-class">.bemjson</span><span class="hljs-class">.js</span>&lt;/a&gt;
│   │   └── &lt;<span class="hljs-tag">a</span> href=<span class="hljs-string">"https://github.com/varya/online-shop-dummy/blob/gh-pages/desktop.bundles/index/index.html"</span>&gt;index.html&lt;/a&gt;</code></pre>


<p>Для понимания bem tools представьте, что это строительный кран. Он берет
строительные блоки и возводит из них дом.</p>
<p><img src="http://img-fotki.yandex.ru/get/9058/14441195.30/0_7e0f3_ff76f66a_L.jpg" alt=""></p>
<p>Хотя, кроме <em>.js, </em>.css и *.html файлов, всё-таки есть один файл, написанный
разрабочиком.
Это
<a href="https://github.com/varya/online-shop-dummy/blob/gh-pages/desktop.bundles/index/index.bemjson.js">index.bemjson.js</a>
— JSON описание того, что за блоки нужны на странице и какова их древовидная
структура. Звучит логично, ведь только человек знает, что нужно показать на
странице. Всё остальное делают bem tools. Получив информацию о том, какие блоки
нужны для страницы, они берут их код из <code>desktop.blocks</code> и формируют с их
помощью страницу.</p>
<p>Продолжая пример со строительством дома, можно сказать что <code>page.bemjson.js</code> —
это чертеж.</p>
<p><img src="http://img-fotki.yandex.ru/get/6704/14441195.30/0_7e1ba_9dacd537_L.jpg" alt=""></p>
<p>Но почему же <code>bem tools</code> нужно регулярное выражение в настройках?</p>
<p>Это несложно. Все папки, которыми оперирует <code>bem tools</code> — это <code>уровни
переопределения</code>. Должно быть легче, если представлять уровень как набор
сущностей. Уровень блоков представлен папкой <code>desktop.blocks</code>, а уровень страниц
— папкой <code>desktop.pages</code>. В конфигурационной папке
<a href="https://github.com/bem/project-stub/tree/14e24fd17ba66a357a2f6fcdce045065b4eb5d6c/.bem/levels">.bem/levels/</a>
есть инструкции, по которым bem tools понимают, что делать с уровнями разных
типов.</p>
<p>Выделяя в проекте блоки и бандлы, можно делать разные наборы блоков и разные
бандлы, собранные из этих наборов. Например, блоки для desktop и touch версий
сайта могут храниться в одном репозитории. И страницы, собранные из таких блоков
— тоже.</p>
<pre class="highlight"><code class="hljs undefined">├── desktop.blocks/
├── desktop.bundles/
├── touch.blocks/
└── touch.bundles/</code></pre>

<p>Возвращаясь к примерам из реального мира, не только кирпичики могут быть
модулями, но и детальки LEGO.</p>
<p><img src="http://img-fotki.yandex.ru/get/6704/14441195.30/0_7e0f6_f69c7d44_L.jpg" alt=""></p>
<p>Из них также можно построить дом. Немножечко другой, конечно.</p>
<p><img src="http://img-fotki.yandex.ru/get/9326/14441195.30/0_7e0f4_3d999550_L.jpg" alt=""></p>
<p>Если пойти дальше, вы можете выделить код блоков, общий для всех платформ, и
хранить его отдельно.</p>
<pre class="highlight"><code class="hljs axapta">├── <span class="hljs-keyword">common</span>.blocks/
├── desktop.blocks/
├── desktop.bundles/
├── touch.blocks/
└── touch.bundles/</code></pre>

<p>С такой структурой desktop версия формируется из кода блоков уровней
<code>common.blocks</code> и <code>desktop.blocks</code>, а touch версия — из уровней <code>common.blocks</code>
и <code>touch.blocks</code>.</p>
<p><img src="http://img-fotki.yandex.ru/get/6725/14441195.30/0_7e0f5_3e107fd4_L.jpg" alt=""></p>
<p>И в заключении, я не перестаю радоваться идее проекта
<a href="https://github.com/bem/project-stub/">BEM project
stub</a>. Сама постоянно использую его,
начиная новые проекты. Туториал о
<a href="http://ru.bem.info/articles/start-with-project-stub/">старте проекта на полном стеке
БЭМ</a> показывает, как именно.
Так же БЭМ использует и знакомый, задавший мне вопрос. Я никогда раньше не
подозревала, что project stub позволяет начать работы с БЭМ без знания всего
того, что описано выше. :-)</p>
<p>Кстати, написав все это, я поняла, что описание основ БЭМ для меня несложно и
занимает разумное время. При этом (я надеюсь!), это очень полезно для других.
Так что спрашивайте всё, что вы хотите знать.</p>
]]></description>
            <link>http://varya.me//ru/issues/blocks-and-bundles</link>
            <guid isPermaLink="true">http://varya.me//ru/issues/blocks-and-bundles</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Wed, 15 Jan 2014 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Бложик на bem tools 1.0.0alpha]]></title>
            <description><![CDATA[<p><a href="http://bem.info/tools/bem/">bem tools</a> &mdash; пакет для сборки проекта с
БЭМ-структурой развивается семимильными шагами. На подходе версия 1.0.0. Точнее,
уже сейчас её можно использовать как alpha. Я попробовала на блоге, и уже этот
текст отображается со статикой, собранной <code>bem tools 1.0.0</code>.<excerpt/></p>
<p>Воспользоваться этой версией можно из ветки
<a href="https://github.com/bem/bem-tools/tree/release-1.0.0">release-1.0.0</a>, то есть
вместо версии написать в package.json</p>
<pre class="highlight"><code class="hljs javascript">  <span class="hljs-string">"dependencies"</span>: {
    ...
    <span class="hljs-string">"bem"</span>: <span class="hljs-string">"git://github.com/bem/bem-tools.git#7b07045b17ff"</span>,
    ...
  },
</code></pre>
<p>Или, ещё легче, структуру проекта можно позаимстровать из
<a href="https://github.com/bem/project-stub/tree/feature/bt-1.0.0">project-stub/feature/bt-1.0.0</a>.
 Вообще <code>project-stub</code> очень удобное изобретение. Я все свои проекты начинаю с
 него. Для перехода между версиями тоже отлично: просто делается сравнение
 текущего проекта с другой веткой project-stub, и при применении всех изменений,
 проект заводится из коробки.</p>
<p>Итак, что у нас нового? Не принципиально в проекте, а с моей пользовательской
точки зрения.</p>
<p>Появилась возможность складывать минимизированные файлы не в
<code>_page.css</code> и <code>_page.js</code>, а в файлы <code>page.min.css</code> и <code>page.min.js</code>. Кстати,
project-stub <a href="https://github.com/bem/project-stub/blob/142e92c58e2ecf0ea3b658f71c203fee214df8d1/.bem/make.js#L34">именно так и
настроен</a>.
Это для меня критичное изменение, потому что оно наконец-то дало возможность
использовать <code>bem tools</code> в блоге. Блог запущен на Jekyll, встроенном в GitHub,
то есть хостится на технологии gh-pages. По умолчанию gh-pages не показывает
файлы, начинающиеся с подчеркивания. Есть трюк — добавить в корень репозитория
файл <code>.nojekyll</code>, но тогда перестаёт работать Jekyll :-) В общем, мне
приходилось пользоваться <a href="https://github.com/enb-make/enb">ENB</a> ради единственной
фичи - возможности минимизировать в <code>page.min.*</code>. ENB хорош, но мейнстрим есть
мейнстрим, прехожу обратно на <code>bem tools</code>.</p>
<p>Еще одно важное user friendly изменение &mdash; уровни страниц теперь не содержат
папку <code>.bem</code> с настройками, по крайней мере по умолчанию. Все настройки
сосредоточены в папке <code>.bem</code> <a href="https://github.com/bem/project-stub/tree/5231f6a2de35dabfd2017574673e40a2a36ed435/.bem">в корне
проекта</a>.</p>
<p>Это изменеие не заметно, если начинать проект с project-stub и ничего не
менять. Тогда не важно, какая структура. А вот внесение изменений стало
психологически комфортнее. По крайней мере точно известно, что надо менять
<code>.bem</code> в корне.</p>
<p>Для доставки библиотек на проект теперь использутеся
<a href="https://github.com/bower/bower">Bower</a>, пакетный менеджер от Twitter. Про него
тоже интересно почитать.</p>
<p>Соответственно, в корне проекта появился файл
<a href="https://github.com/bem/project-stub/blob/5231f6a2de35dabfd2017574673e40a2a36ed435/bower.json">bower.json</a>
со списком библиотек.</p>
<pre class="highlight"><code class="hljs javascript">{
    <span class="hljs-string">"name"</span>: <span class="hljs-string">"bem-project-stub"</span>,
    <span class="hljs-string">"version"</span>: <span class="hljs-string">"0.0.1"</span>,
    <span class="hljs-string">"dependencies"</span>: {
        <span class="hljs-string">"bem-core"</span>: <span class="hljs-string">"9e5dc255421304fd652552c948cdf7af35dc8a68"</span>,
        <span class="hljs-string">"bem-components"</span>: <span class="hljs-string">"bem/bem-components"</span>
    }
}
</code></pre>
<p>И служебный файл <a href="https://github.com/bem/project-stub/blob/5231f6a2de35dabfd2017574673e40a2a36ed435/.bowerrc">.bowerrc</a>.</p>
<p>Вместе с новой версией <code>bem tools</code> блог теперь пользуется новыми библиотеками,
хотя вообще это не взаимосвязано &mdash; библиотеки могут быть использованы и со старым
сборщиком.</p>
<p>Вместо <code>bem-bl</code> в основе лежат блоки библиотеки <a href="https://github.com/bem/bem-core/tree/v1">bem-core</a>.
Она только только <a href="http://clubs.ya.ru/bem/replies.xml?item_no=4301">анонсирована</a>.
Миграция на библиотеку делается <a href="https://github.com/bem/bem-core/blob/v1/MIGRATION.ru.md">по инструкции</a>,
и она несложная. Несмотря на введение нового JavaScript-based синтаксиса для
BEMHTML шаблонов, старый лаконичный синтаксис тоже поддерживается. Так что в моём
случае нужно было только перевести JavaScript блоков на новую модульную систему.
<a href="https://github.com/varya/bem-js-tutorial">Туториал по BEM JavaScript</a> как обычно
&mdash; готовится.</p>
<p>Таким образом, сборка блога наконец-то вошла в относительно стабильное состояние,
а я теперь могу заниматься его контентом и улучшением frontend части.</p>
]]></description>
            <link>http://varya.me//ru/issues/bem-tools-100-alpha</link>
            <guid isPermaLink="true">http://varya.me//ru/issues/bem-tools-100-alpha</guid>
            <dc:creator><![CDATA[Varya Stepanova]]></dc:creator>
            <pubDate>Fri, 01 Nov 2013 00:00:00 GMT</pubDate>
        </item>
    </channel>
</rss>